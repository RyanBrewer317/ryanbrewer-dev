<!doctype html>
<div><div><title>Cat - Ryan Brewer</title><meta name="description" content><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><script>hljs.highlightAll();</script></div><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Ryan Brewer</a><a href="/posts" id="nav-posts" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Posts</a><a href="/wiki" id="nav-wiki" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Wiki</a><a href="/contact" id="nav-contact" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Contact</a><a href="/demos" id="nav-demos" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Demos</a><a href="/feed.rss" id="nav-subscribe" onclick="window.location.href = &#39;/feed.rss&#39;"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Cat</h1><p><span>\(\texttt{Cat}\) is a <a href="/wiki/large-and-small-categories"><span>large category</span></a> where all <a href="/wiki/large-and-small-categories"><span>small categories</span></a> are its objects. This means that when you&#39;re doing some work with a small category, you&#39;re also working in \(\texttt{Cat}\), giving you arrows, between your category and other categories, that you can actually use to help with your reasoning. The arrows in \(\texttt{Cat}\) are called &quot;<a href="/wiki/functor"><span>functors</span></a>,&quot; and they&#39;re functions (really <i><span>mappings,</span></i> in the event of a large or locally large category where they can&#39;t be functions) mapping objects of some category \(C\) into objects of some category \(D\), and mapping the arrows in \(C\) to arrows in \(D\).
</span></p><p><span>Functors also get an extra restriction: functors must preserve commuting diagrams. What this means is that composition and identity must be preserved: \(F(g\circ f)=Fg\circ Ff\) and \(F(id_X)=id_{FX}\). (Category theory doesn&#39;t do parentheses for applying mappings to things; \(Fg\) might be written \(F(g)\) in what you&#39;re used to.) That preservation condition is an important idea and worth thinking about a little, and hopefully will become more clear in the coming paragraphs. It makes functors a sort of homomorphisms, if you&#39;re familiar with group theory or related fields of abstract algebra. In more friendly language, functors are required to preserve the structure of a category. So if I have some diagram in my category \(C\) then a functor \(F:C\to D\) gives me a diagram in \(D\) that can be drawn in a very similar way: 
</span></p><div class="diagram"><img src="/image-0-cat.svg" onload="this.width *= 2.25;"></div><p><span>\(\texttt{Cat}\) has <a href="/wiki/exponential-object"><span>exponential objects</span></a> too (objects representing arrows), called &quot;functor categories.&quot; Remember, the objects of \(\texttt{Cat}\) are categories, so exponential objects are categories. A functor category representing the arrows in \(\texttt{Cat}\) from a category \(C\) to a category \(D\) is written \([C,D]\) (or, in typical exponential notation, \(D^C\)). The objects in such a category are functors from \(C\) to \(D\). The arrows transform one functor to another, and are called &quot;<a href="/wiki/natural-transformation"><span>natural transformations</span></a>.&quot; Similar to how functors are like functions with an extra restriction that makes them useful, natural transformations are transformations that satisfy a &quot;naturality condition,&quot; hence calling them &quot;natural.&quot; Formally, for two functors \(F,G:C\to D\), a natural transformation \(\alpha:F\Rightarrow G\) is a family of morphisms in \(D\) transforming &quot;outputs&quot; of \(F\) into &quot;outputs&quot; of \(G\). Namely, \(\alpha_X:FX\to GX\). The naturality condition that natural transformations must satisfy is depicted below as a diagram that must commute, and also illuminates how the transformation works:
</span></p><div class="diagram"><img src="/image-1-cat.svg" onload="this.width *= 2.25;"></div><p><span>That is, \(Gf\circ\alpha_X=\alpha_Y\circ Ff\). Note that this entire diagram takes place in \(D\), and the only mention of \(C\) are \(X\) and \(Y\), which are objects in \(C\).
</span></p><p><span>I&#39;ve heard many times that being able to talk about and study natural transformations is the original &quot;point&quot; of category theory. Note once more that natural transformations, transforming functors into other functors, aren&#39;t some new special feature we just added to category theory. They&#39;re just arrows in categories! Not only that, but their abstract meaning in a functor category is more concrete in the categories functors act on, where they are just families of arrows. In functional programming we&#39;re quite comfortable with families of morphisms: they&#39;re (parametrically) polymorphic functions! Indeed, it&#39;s been proven that a parametrically-polymorphic function <code><span>f&lt;T&gt;: F&lt;T&gt; -&gt; G&lt;T&gt;</span></code> (or, in a more Haskelly notation, <code><span>f :: F a -&gt; G a</span></code>) satisfies the naturality condition and and is a natural transformation if <code><span>F</span></code> and <code><span>G</span></code> are functors. So the abstract-ness of natural transformations gets concrete pretty quickly in, say, a language like Haskell.
</span></p><p><span>One of the main reasons natural transformations felt like arcane magic to me for a long time was that people often draw them as arrows between arrows, like so:
</span></p><div class="diagram"><img src="/image-2-cat.svg" onload="this.width *= 2.25;"></div><p><span>This makes it appear as though there&#39;s some new thing we&#39;re allowed to do with categories, while in reality a natural transformation is just another regular morphism in some category somewhere.
</span></p><p><span>Because \(\texttt{Cat}\) is enriched over \(\texttt{Cat}\), the arrows between two objects (categories) form a category, and we can say there are arrows between the arrows. That&#39;s what leads to the above notation of natural transformations as arrows between arrows. We call \(\texttt{Cat}\) a <a href="/wiki/2-category"><span>&quot;2-category&quot;</span></a> because there are arrows between the arrows, the idea being that a set is only objects and is a &quot;0-category,&quot; and then adding arrows between objects is a &quot;1-category.&quot; If you have arrows between arrows between arrows then it&#39;s a 3-category. Note that the category of 1-categories (which is \(\texttt{Cat}\)) is a 2-category; the category of 2-categories is a 3-category and this pattern continues indefinitely. I&#39;m told advanced researchers are studying \(\infty\)-categories but we&#39;re well beyond what I know now!
</span></p><p><span>\(\texttt{Cat}\) is also a cartesian category, with <a href="/wiki/product-category"><span>product categories</span></a> as the cartesian product. It is also monoidal closed (because it&#39;s enriched over itself), with <a href="/wiki/functor-category"><span>functor categories</span></a> as the exponential objects as I mentioned above. Thus \(\texttt{Cat}\) is a cartesian closed category.</span></p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div>