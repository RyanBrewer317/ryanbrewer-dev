<!doctype html>
<html><body><div><div><link as="image" href="/ryan-ferry.jpg" rel="preload"><link href="/ryan-silly-2.png" rel="prefetch"><title>Monoid - Ryan Brewer</title><meta content name="description"><script async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" type="text/javascript"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode','[tex]/bussproofs']},
  tex: {packages: {'[+]': ['unicode','bussproofs']}},
};
        </script><script>hljs.highlightAll();</script></div><nav id="nav"><script>
function click_nav_home_link() {
  let p=new URL(location.href).pathname;
  if(p=='/'){
    document.getElementById('nav').classList.remove('dropdown');
  }
  document.body.classList.remove('noscroll');
}
function click_nav_link(route) {
  let p=new URL(location.href).pathname;
  if(p==route||p==route+'/'){
    document.getElementById('nav').classList.remove('dropdown');
  }
  document.body.classList.remove('noscroll');
}
    </script><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home" onclick="click_nav_home_link()">Ryan Brewer</a><a href="/contact" id="nav-contact" onclick="click_nav_link(&#39;/contact&#39;)">Contact</a><a href="/demos" id="nav-demos" onclick="click_nav_link(&#39;/demos&#39;)">Demos</a><a href="/posts" id="nav-posts" onclick="click_nav_link(&#39;/posts&#39;)">Posts</a><a href="/projects" id="nav-projects" onclick="click_nav_link(&#39;/projects&#39;)">Projects</a></nav><div id="body"><h1>Monoid</h1><p><span>Monoids are the formal concept of &quot;and then.&quot; You&#39;ve got some set of things \(S\), and you can put two of them together to get another thing in \(S\). If \(S\) is actions, then doing one &quot;and then&quot; the other is a new action, so it&#39;s also in \(S\). Monoids also have something in \(S\) for &quot;doing nothing,&quot; so if you &quot;do nothing and then&quot; something, you only did one thing, and if you do something &quot;and then do nothing,&quot; you only did one thing. If we call our &quot;and then&quot; operator \(\otimes\), and our &quot;do nothing&quot; element \(e\), then we write the monoid \((S,\otimes,e)\).
</span></p><p><span>To properly capture the idea of &quot;and then,&quot; we need to say that \(\otimes\) is associative, and that \(e\) is an identity for \(\otimes\). That just means three equations need to be true: \(a\otimes(b\otimes c)=(a\otimes b)\otimes c\), \(e\otimes a=a\), and \(a\otimes e=a\).
</span></p><p><span>The most common example of a monoid is the set of natural numbers with addition, \((\mathbb{N},+,0)\). We can also use multiplication, \((\mathbb{N},\times,1)\). For addition, the idea is that \(2+3\) is \(2\) &quot;and then&quot; \(3\), which, by choosing \(+\), we&#39;ve defined to mean \(5\). When we choose multiplication instead, \(2\) &quot;and then&quot; \(3\) means \(6\) instead. And notice how the &quot;do nothing&quot; element changed as well.
</span></p><p><span>The &quot;do nothing&quot; element is formally called the &quot;identity&quot; element or &quot;neutral&quot; element. The &quot;and then&quot; thing is formally called the &quot;operator&quot; or &quot;product.&quot; The set of things is formally called the &quot;underlying set&quot; or &quot;carrier set.&quot;
</span></p><p><span>Notice that not all monoids are commutative; that is, \(a\otimes b\) doesn&#39;t always equal \(b\otimes a\). In general, \(a\) &quot;and then&quot; \(b\) is not the same as \(b\) &quot;and then&quot; \(a\). An example follows.
</span></p><p><span>The most representative monoid for a set \(S\) is the set of <i><span>lists</span></i> of elements of \(S\). This is formally called the &quot;free monoid&quot; for \(S\), since we can generated a monoid &quot;for free&quot; from the elements of \(S\) using lists. If \(S\) is \(\mathbb{N}\), then some example elements in the carrier set of the free monoid are \([1,1,7]\) and \([9,3]\). Putting them together gives \([1,1,7,9,3]\), this is formally called &quot;concatenation.&quot; The identity element is the empty list, \([]\). Writing \(\oplus\) for concatenation, the free monoid is \(([S],\oplus,[])\). Notice that this monoid operator is not commutative, since \([1,1,7]\oplus[9,3]\) is not the same as \([9,3]\oplus[1,1,7]\).
</span></p><p><span>Why are lists the most representative monoid for a set? Any monoid whose carrier set is \(S\) can be seen as an equivalence class of the free monoid. For example, \((\mathbb{N},+,0)\) can be seen as (\([\mathbb{N}],\oplus,[]\)), except that we consider two lists equivalent when their sums are equal. So \([1,1,7]\equiv[9]\equiv[5,0,4,0,0]\), etc. When we add these equivalences, concatenation behaves just like addition, and the empty list behaves just like zero. As another example, you can hopefully see how seeing lists as equivalent when their <i><span>products</span></i> are equal then gives the multiplication monoid \((\mathbb{N},\times,1)\).
</span></p><p><span>A generalization of monoids is a &quot;<a href="/wiki/category"><span>category</span></a>,&quot; which perhaps encodes the idea of &quot;and then&quot; even better than monoids do. In a category, it&#39;s like the things are jigsaw-puzzle pieces, and the &quot;and then&quot; operation (called &quot;composition,&quot; written \(a\circ b\)) is gluing them together. It&#39;s a generalization of monoids because pieces can only be put together when their edges match up: \(a\) might have an \(x\) edge on the left and a \(y\) edge on the right, so \(a\circ b\) is only possible if \(b\) has a \(y\) edge on the left. For categories we write things like \(a:x\to y\) to talk about the left and right edges of \(a\). The identity element has matching edges on both sides, but now there&#39;s an identity element for every kind of edge. A category becomes a monoid when all the edges on all the pieces are the same, so there&#39;s only one kind of edge and any two objects can be put together in either order to make a third object.</span></p></div><div><p class="subtle-text" id="copyright-notice">© 2025 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div></body></html>