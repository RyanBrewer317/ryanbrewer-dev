<!doctype html>
<div><div><title>Security Types - Ryan Brewer</title><meta name="description" content><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><script>hljs.highlightAll();</script></div><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Ryan Brewer</a><a href="/posts" id="nav-posts" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Posts</a><a href="/wiki" id="nav-wiki" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Wiki</a><a href="/contact" id="nav-contact" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Contact</a><a href="/demos" id="nav-demos" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Demos</a><a href="/feed.rss" id="nav-subscribe" onclick="window.location.href = &#39;/feed.rss&#39;"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Security Types</h1><p><span>Security types are a niche area of type theory research that allow expressions about what a computation is allowed to know about. This has obvious applications to security and privacy, but security type theory has also been used in many other applications, such as binding-time analysis, <a href="http://dx.doi.org/10.1007/978-3-319-89722-6_4"><span>garbage collection</span></a>, <a href="http://dx.doi.org/10.1145/3607852"><span>non-termination with dependent types</span></a>, and more.
</span></p><p><span>The initial insight in the field is that information security is <a href="/wiki/monad"><span>monadic</span></a>. To illustrate this, consider a value \(v\) of type \(a\) that is secret. We&#39;ll use a <a href="/wiki/functor"><span>functor</span></a> \(T\) for secrecy, so we say that the type is \(Ta\). We can compute with \(v\) as long as the result of our computation is also secret: for \(f:a\to b\), we can do \(Tf:Ta\to Tb\). That&#39;s all normal functor stuff, but here&#39;s the monadic part: if the result of our computation is secret, then we don&#39;t really make the result &quot;double secret,&quot; that would be silly. So if we have \(f:a\to Tb\), then \(Tf:Ta\to T(Tb)\), and we use \(\mu_b:T(T(b))\to Tb\) to squash the secrecy. This doesn&#39;t reveal the secret, because the result is still secret: we have no way to go from \(Tb\) to \(b\). The other monadic thing is \(eta_a:a\to Ta\), because we can always make something secret if we want to. 
</span></p><p>[<span>DCC](https://www.cs.cornell.edu/andru/cs711/2003fa/reading/abadi99core.pdf) was really the birth of this field, making the first step of the \(T\) monad. They went on to have a predetermined set of security levels. The set is a lattice, meaning that for two levels \(l_1\) and \(l_2\) there&#39;s a least upper bound \(l_1\lor l_2\) and a greatest lower bound \(l_1\land l_2\). Furthermore, since it&#39;s a lattice, there&#39;s a preorder over the levels, that is, a reflexive, transitive relation \(l_1\le l_2\). As you might expect, higher security levels can depend on information at lower security levels, but not vice versa.
</span></p><p><span>But what if we didn&#39;t make a secrecy functor \(T\)? What if values were secret by default, and there was a <i><span>publicity</span></i> functor \(P\)? In this case, \(P\) is a <a href="/wiki/monad"><span>comonad</span></a>: \(\varepsilon_a:Pa\to a\) means public values can be made secret, and \(\delta_a:Pa\to P(Pa)\) means public values can be &quot;publically public;&quot; if you drop the information that it&#39;s publically-public, then you still know that it&#39;s public. This is important because if we take a public value \(v:Pa\) and apply a function that returns a secret value \(f:Pa\to b\), the truth is that that first value was made public before, so the public knows about it, so this new value only depends on public information, so it&#39;s not really secret, and we can have a value of type \(Pb\). This is done with \(Pf\circ\delta:Pa\to Pb\), which proves the fact that \(Pb\) can be deduced from \(Pa\) and \(Pa\to b\). These ideas are explored more in <a href="https://arxiv.org/abs/2209.06334"><span>this paper</span></a>.
</span></p><p><span>Note that when I say &quot;made secret&quot; I don&#39;t mean redacted, I literally mean forgetting that it was public. The key idea of security type theory is that once something is shown to the public, the public can be remembering, using, and depending on that information potentially forever. So the monadic aspect keeps information in a secrecy monad to show that secret things can only lead to secret things, and the comonadic aspect allows you to remember that public things are still public; they&#39;re two different ways of looking at that same information-behavior.
</span></p><p><span>The very brilliant reader may have noticed that these rules parallel the rules of S4 modal logic. The secrecy monad is like the possibility modality (which is indeed a monad) and the publicity comonad is like the necessity modality (which is indeed a comonad). For example, \(\Box p\land(\Box p\Rightarrow q)\Rightarrow\Box q\), because \(\Box p\Rightarrow\Box\Box p\) and \(\Box p\land(p\Rightarrow q)\Rightarrow\Box q\). I have a blog post all about this <a href="/posts/security-crashing-modal-logic"><span>here</span></a>, and I think it&#39;s really cool!</span></p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div>