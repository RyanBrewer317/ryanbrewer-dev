<!doctype html>
<html><body><div><div><link as="image" href="/ryan-ferry.jpg" rel="preload"><link href="/ryan-silly-2.png" rel="prefetch"><title>Adjunction - Ryan Brewer</title><meta content name="description"><script async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" type="text/javascript"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode','[tex]/bussproofs']},
  tex: {packages: {'[+]': ['unicode','bussproofs']}},
};
        </script><script>hljs.highlightAll();</script></div><nav id="nav"><script>
function click_nav_home_link() {
  let p=new URL(location.href).pathname;
  if(p=='/'){
    document.getElementById('nav').classList.remove('dropdown');
  }
  document.body.classList.remove('noscroll');
}
function click_nav_link(route) {
  let p=new URL(location.href).pathname;
  if(p==route||p==route+'/'){
    document.getElementById('nav').classList.remove('dropdown');
  }
  document.body.classList.remove('noscroll');
}
    </script><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home" onclick="click_nav_home_link()">Ryan Brewer</a><a href="/contact" id="nav-contact" onclick="click_nav_link(&#39;/contact&#39;)">Contact</a><a href="/demos" id="nav-demos" onclick="click_nav_link(&#39;/demos&#39;)">Demos</a><a href="/posts" id="nav-posts" onclick="click_nav_link(&#39;/posts&#39;)">Posts</a><a href="/projects" id="nav-projects" onclick="click_nav_link(&#39;/projects&#39;)">Projects</a></nav><div id="body"><h1>Adjunction</h1><p><span>An adjunction \(F\dashv G\) between two <a href="/wiki/category"><span>categories</span></a> \(C\) and \(D\) is a pair of <a href="/wiki/functor"><span>functors</span></a> \(F:D\to C\) and \(G:C\to D\) that satisfy the isomorphism \(F a\to b\cong a\to G b\), where \(a\) is in \(D\) and \(b\) is in \(C\). Informally, adjunctions let you move something from one side of an arrow to the other, by swapping that something.
</span></p><p><span>In this example, \(C\) is said to be on the left, \(F\) is said to be going to the left, \(D\) is said to be on the right, and \(G\) is said to be going to the right. Thus it is common to use the letters \(L\) and \(R\) instead of \(F\) and \(G\) respectively. This idea of &quot;left&quot; and &quot;right&quot; are based on the following way of drawing adjunctions:
</span></p><div class="diagram"><img onload="this.width *= 2.25;" src="/image-0-adjunction.svg"></div><p><span>Now, we have to be careful when reading this! Remember that the left and right are in different categories, and the horizontal arrows are functors instead of arrows in either of the two categories. 
</span></p><p><span>Anyway, in this diagram, the adjunction means each \(f\) has a \(g\) in one-to-one correspondence: as an isomorphism of <a href="/wiki/homset"><span>homsets</span></a>, \(C(La,b)\cong D(a,Rb)\).
</span></p><p><span>If it&#39;s hard to imagine an isomorphism like this, let&#39;s take a simple example: currying. Let&#39;s take some ordinary category of types and functions, which we&#39;ll call \(C\). A multiple-argument function will be a morphism from a cartesian product, so for example \(\texttt{add}:\texttt{int}\times\texttt{int}\to\texttt{int}\). But as functional programmers, we know that there&#39;s an equivalent version of \(\texttt{add}\), where we curry it: \(\texttt{add}_c:\texttt{int}\to(\texttt{int}\to\texttt{int})\). We can draw this nice diagram:
</span></p><div class="diagram"><img onload="this.width *= 2.25;" src="/image-1-adjunction.svg"></div><p><span>Now, if we&#39;re slightly more familiar with category theory, we might realize that \(-\times\texttt{int}\) is a functor, and so is \(\texttt{int}\to-\). So we can add those arrows to our diagram, to make it look very familiar:
</span></p><div class="diagram"><img onload="this.width *= 2.25;" src="/image-2-adjunction.svg"></div><p><span>Again, be weary that the arrows here are from up to three different categories, so it&#39;s not really a commutative diagram.
</span></p><p><span>The equivalence of multi-parameter functions and curried functions is an adjunction! I&#39;m being informal in my presentation but hopefully you can roughly see the technical details. Specifically, it&#39;s actually a family of adjunctions, based on all the possible types of the second parameter. We can write this adjunction like this: \(-\times A\dashv A\to-\), for the various types \(A\).
</span></p><p><span>Now to test our new equational powers: \(La\to b\cong a\to Rb\) means, in this case, \(a\times c\to b\cong a\to c\to b\). That&#39;s true! Going back and forth along that isomorphism is exactly currying and uncurrying!
</span></p><p><span>Now, one thing to notice is that this doesn&#39;t work if you swap the two functors. The left one is on the left, and the right one is on the right; the order matters. Therefore we talk about the &quot;left adjoint functor&quot; and the &quot;right adjoint functor.&quot; If there&#39;s an adjunction \(F\dashv G\), then we say \(F\) has a &quot;right adjoint,&quot; namely \(G\), and \(G\) has a &quot;left adjoint,&quot; namely \(F\).
</span></p><h3><span>Unit, Counit, Monads
</span></h3><p><span>Now, at this point in the wiki entry you might be a little confused. Adjunctions are often talked about in discussions about <a href="/wiki/monad"><span>monads</span></a>, and often defined with a &quot;unit&quot; and &quot;counit.&quot; So here&#39;s the craziest part about adjunctions, that makes them absolutely beautiful.
</span></p><p><span>Remember that adjunction diagram from before? What if we pick \(La\) as our \(b\)?
</span></p><div class="diagram"><img onload="this.width *= 2.25;" src="/image-3-adjunction.svg"></div><p><span>Well, now we actually know of an \(f\) that must exist: the identity morphism of \(La\)! And since there&#39;s a one-to-one correspondence between \(f\)s and \(g\)s, we know of a \(g\) that must exist as well, namely, whatever is assigned to \(id_{La}\) in the correspondence. We&#39;ll call whatever this is \(\eta:a\to R(La)\), or the &quot;unit.&quot;
</span></p><p><span>Obviously, we can do the same thing on the other side, with \(a=Rb\) instead:
</span></p><div class="diagram"><img onload="this.width *= 2.25;" src="/image-4-adjunction.svg"></div><p><span>By the same logic, there must be something in correspondence with \(id_{Rb}\), which we&#39;ll call \(\varepsilon:L(Rb)\to b\), or the &quot;counit.&quot;
</span></p><p><span>(This is getting somewhere cool soon, just bear with me a moment!)
</span></p><p><span>Now, if we remember that \(a\) is the same as \(Id_C\; a\), the identity functor on \(C\) mapping the object \(a\) to itself, then we can see \(\eta:a\to R(La)\) as a transformation between functors \(\eta:Id_C\to R\circ L\). Similarly, \(\varepsilon:L\circ R\to Id_C\). In fact, the unit and counit are both <a href="/wiki/natural-transformation"><span>natural transformations</span></a>.
</span></p><p><span>Now here&#39;s where things start to ramp up in coolness. The unit is actually always the unit of a monad \(R\circ L\), where the join operator \(\mu_a:R(L(R(La)))\to R(La)\) is defined as \(\mu=R\circ\varepsilon\circ L\) using <a href="/wiki/natural-transformation"><span>horizontal composition</span></a>. But, far crazier, <i><span>every</span></i> monad is based on an adjunction in exactly this way. In the case of our currying adjunction above, we get the State monad! And every <a href="/wiki/monad"><span>comonad</span></a> is \(L\circ R\) for an adjunction \(L\dashv R\), using the counit of the comonad and \(\delta=L\circ\eta\circ R\); in the case of our currying example above, we get the Store comonad. 
</span></p><p><span>Here&#39;s a massive diagram to show where a monad and comonad come out of an adjunction. I drew it this way so that the left adjoint always goes to the left and the right adjoint always goes to the right. Try using the functors from our currying example above to get the definition of the State monad and Store comonad!
</span></p><div class="diagram"><img onload="this.width *= 2.25;" src="/image-5-adjunction.svg"></div><p><span>As crazy as it is that monads and comonads are inter-definable via adjunctions in this way, the main mathematical use of adjunctions is in the nice equation \(La\to b\cong a\to Rb\), or more generally written \(C(La,b)\cong D(a,Rb)\). So this &quot;homset isomorphism&quot; is the main way they come up in math and category theory, even if the unit/counit definition feels more concrete and/or usable to the peasant functional programmer.
</span></p><p><span>Also, it&#39;s worth mentioning that an adjunction can be completely defined just by giving the unit and counit; the homset isomorphism can be derived from them. A morphism \(f:La\to b\) is mapped to \(R(f)\circ\eta:a\to Rb\), and a morphism \(g:a\to Rb\) is mapped to \(\varepsilon\circ Lg:La\to b\); try going back and forth to check that this is indeed an isomorphism. This means that the unit/counit perspective is often called a &quot;formulation&quot; or &quot;definition&quot; of adjunctions, where as the homset isomorphism is another formulation/definition.</span></p></div><div><p class="subtle-text" id="copyright-notice">© 2025 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div></body></html>