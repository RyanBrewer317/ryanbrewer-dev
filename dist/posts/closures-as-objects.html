<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Closures As Objects - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="bonk"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer's Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script>  <script type="module" crossorigin src="/assets/style-b7ef9c88.js"></script>
  <link rel="stylesheet" href="/assets/style-d6c1c3cd.css">
</head><body><nav><a href="/" id="nav-home">Ryan Brewer</a><a href="/search" id="nav-search">Posts</a><a href="/contact.html" id="nav-contact">Contact</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Closures As Objects</h1><div class="date">March 5, 2024</div><p>In this post I discuss an unorthodox way of implementing closures in a programming language, which takes advantages of the fact that closures and single-method OOP-style objects have some correspondence.
</p><p>I actually had this thought when I was reading about the <a href="https://en.wikipedia.org/wiki/OBJ_(programming_language)">OBJ</a> programming language, but I think the ideas I&#39;m about to discuss may be more similar to how Java implements its closures.
</p><h3>The Problem
</h3><p>One might well ask, &quot;why do we need new ways of implementing closures? Nowadays every mainstream language seems to be getting along fine.&quot; Well, honestly, I think the most popular mainstream languages (JavaScript, Python, Java; the OOP languages) <i>already</i> use something related to what I&#39;ll discuss. I claim no novelty here. The problem I&#39;m addressing is how <i>functional</i> languages implement closures. 
</p><p>The canonical idea behind closures in a functional language goes something like this: a function needs to be able to access variables from the scope in which it was defined. Therefore, the function needs to carry around the values it uses from its scope. Great, we&#39;ll just have a struct with the function pointer and the values, and pass that around. To call this closure, you take out the function pointer and call it, passing in these extra values for it to use. 
</p><p>Then at some point you sit down and design the compilation of a function like <code>map</code>, which takes a function and a list and calls the function on everything in the list to produce a new list. When <code>map</code> is compiled, we know it needs to get passed in a function, <i>but now there are two types of functions.</i> Are we expecting a struct, or a code pointer? If we decide to compile it for the former, then we can give <code>map</code> closures, but we can&#39;t give it our top-level functions that have no captured values. If we decide to compile it for the latter, then we can give <code>map</code> our top-level functions, but we can&#39;t give it closures.
</p><p>The canonical response to this is to simply put everything in closures. That way, we compile higher-order functions like <code>map</code> to take closures, and now we can give it anything, since functions have been &quot;closure-converted.&quot; Yes, a bunch of these structs will have nothing but a code pointer, but it works.
</p><p>The problem with this approach, if it isn&#39;t obvious, is that there&#39;s suddenly a bunch of overheap. Closures are typically heap-allocated, and now every function call is reading somewhere in memory. Functional code, hence the name, has a lot of functions and a lot of function calls.
</p><h3>Solutions
</h3><p>There are many ways to improve on this, of course. &quot;Lambda-lifting&quot; transforms the whole program to pass the values around without a struct, at the cost of separate compilation. In plenty of cases the best this can do is still putting things in and out of structs, but it can be an improvement. You can also do some escape analysis to see if you know enough about the callsites of a closure to be able to skip the allocations and instead modify the callsites. Yet another very common approach (I believe Haskell and OCaml do this) is to simply optimize heap allocation using arena allocators with reserved registers, making the heap allocation of closures much cheaper. Rust, as far as I can tell, will look at every callsite of <code>map</code> and pump out different copies of <code>map</code> for different callsites.
</p><p>Object-oriented languages (Java, JavaScript, Python) do something similar to closure conversion. JavaScript and Python functions are all objects, which is a bit like putting everything in structs. Java doesn&#39;t even have functions, only methods, so &quot;function calls&quot; are always taking function pointers from a datastructure (the object&#39;s vtable) and giving the method the object itself (as the <code>this</code> implicit argument).
</p><p>However, Java&#39;s lambdas are strange. They look like anonymous functions, but really they&#39;re objects from <i>anonymous single-method classes</i> which satisfy an interface. If you have a method like <code>map</code> in java, then it will have to take an argument of that <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">&quot;Functional Interface&quot;</a> type. Thus the codegen for it will call the method on the functional interface. If you want to pass in methods, Java gives you <i>method references</i> where you write <code>ClassName::methodName</code> or <code>objectName::methodName</code> as a special syntax, which can be thought of as something like <code>x -&gt; ClassName.methodName(x)</code> or <code>x -&gt; objectName.methodName(x)</code>. That is, the method gets wrapped up in an anonymous class to meet the functional interface too.
</p><p>That may sound ridiculous. I mean, having only methods and no functions is already ridiculous, and probably what lead to this whole convoluted mess. But now lets take a moment to look at OBJ.
</p><p>OBJ is a &quot;rewrite-based language,&quot; where you specify a list of rewrite rules and the language applies them to a value over and over until no more apply. In one way this is like a generalization of functional programming: a function is like a rewrite rule from a <code>foo(bar)</code> expression to the body of <code>foo</code> where the parameters are replaced with <code>bar</code>. That rewrite rule gets applied repeatedly until there are no more <code>foo(bar)</code> expressions left. But in another way this is very much not a generalization of functional programming: there are no lambdas. Rewrite rules have no way of expressing variable binders (unless you try the recent &quot;Nominal Rewriting&quot;). The authors make the compelling argument that first-order computation is easier to read and think about for programmers, and easier to prove correct. So OBJ can be seen as an interesting attempt to make lambda-free functional programming as expressive and convenient as possible.
</p><p>Now, I won&#39;t show OBJ syntax here, because it&#39;s absolutely awful for someone more used to ML-style or C-style syntax like myself. The paper I&#39;m basing this off of can be found <a href="https://www.researchgate.net/publication/2238131_Higher_Order_Functions_Considered_Unnecessary_for_Higher_Order_Programming">here</a>, with a PDF accessible <a href="https://cseweb.ucsd.edu/~goguen/pps/utyop.pdf">here</a>. But to continue our running example, here&#39;s how the OBJ authors write <code>map</code>: they write a &quot;Theory&quot; (basically an interface) with a single function, then <code>map</code> is in a Module (like a class) that gets parameterized by another module that satisfies the interface. This starts to sound like functional interfaces. <code>map</code> calls the function in the interface on each item of a list, etc. etc.
</p><p>This approach could be seen as having the user create an object (the module) whenever they want it to close over some values, and then using an interface as a way to pass the struct to things that expect a function. Of course, they introduce syntax sugar for making this process more concise.
</p><p>So why am I so excited about this? Well, this gives OBJ ways of expressing closures when you need that kind of expressivity, but while still allowing function calls in the general case to be not-closures, potentially opening the door to a big performance improvement. Let me explain clearly. In a hypothetical language, you can have a functional interface for higher-order functions like <code>map</code> to use as their argument type. In the codegen for <code>map</code> you still need to call it as a closure. At the callsites of <code>map</code> you wrap top-level functions in closures. Now, all of a sudden, programs that don&#39;t use higher-order functions do zero closure-related work! It&#39;s like a <i>lazy</i> closure conversion, where functions are only closure converted when it becomes necessary, and normal function calls aren&#39;t affected.
</p><p>Maybe this is what the hyper-optimized OCaml and Haskell compilers are actually doing already, but it certainly isn&#39;t discussed in the common literature about closures, both in academic papers and on the internet. The common closure conversion algorithms closure convert everything upfront.
</p><p>Note that OBJ doesn&#39;t really go that route. They use a VM and ridiculously expressive rewrite rules and aren&#39;t really trying to maximize performance. But reading through they&#39;re attempt at avoiding lambdas was very eye-opening for me, as someone who&#39;s thought a fair ammount about the ambient performance hits of having closures in your language.
</p><h3>Conclusion
</h3></div><div><div style="height:100pt;"></div><script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script><script>
  kofiWidgetOverlay.draw('ryanbrewer', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Support me',
    'floating-chat.donateButton.background-color': '#323842',
    'floating-chat.donateButton.text-color': '#fff'
  });
    </script><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>