<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Simple Programming Languages - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="bonk"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer's Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script>  <script type="module" crossorigin src="/assets/style-b7ef9c88.js"></script>
  <link rel="stylesheet" href="/assets/style-d6c1c3cd.css">
</head><body><nav><a href="/" id="nav-home">Ryan Brewer</a><a href="/search" id="nav-search">Posts</a><a href="/contact.html" id="nav-contact">Contact</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Simple Programming Languages</h1><div class="date">March 20, 2024</div><p>I love simple programming languages, like Gleam, Go, and C. I know I&#39;m not alone; there&#39;s something wonderful about using a simple language: reading it, using it in a team, coming back to it after a long time, the list goes on.
</p><p>In this post I want to make this kind of simplicity more precise and talk about some reasons it&#39;s important.
</p><h3>Ready-At-Hand
</h3><p>In the philosophy of technology there&#39;s a very useful concept: &quot;presence-at-hand&quot; vs. &quot;readiness-at-hand.&quot; When something is present-at-hand, it&#39;s currently taking up our thoughts and in our immediate consciousness. If it&#39;s instead ready-at-hand, it&#39;s like we can&#39;t even tell that it&#39;s there until we want to use it. For example, when we walk into our kitchen for the millionth time, we&#39;re not really aware of all the cupboards, food, appliances, table, chairs, decorations, or whatever else you have in your kitchen. At least for me, it&#39;s almost like I only see the fridge if I&#39;m coming for a quick bite. As I sit down, I become aware of the table and chairs, which were ready-at-hand and now become present-at-hand, and I don&#39;t think a single thought about the fridge, which becomes ready-at-hand.
</p><p>Just because you&#39;re using something doesn&#39;t make it become present-at-hand. Glasses, for example, remain ready-at-hand even as you see through them, because your mind acts as if they aren&#39;t even there. However, when you use ready-at-hand things and they <i>disfunction</i> then they become present-at-hand: dirt on your glasses makes the presence of the glasses suddenly very loud to your mind.
</p><p>This is like the idea of a small working memory that limits the number of concepts you can juggle in your mind at once, but generalized to include how we filter out noise from all the sense data we&#39;re constantly bombarded with.
</p><p>I bring up this idea of readiness-at-hand because simple programming languages often <i>do</i> have many features, but they&#39;re designed to stay invisible to our mind whenever we&#39;re not using them. For example, Gleam, Go, and C are all very cross-platform, and making them support more platforms is a big chunk of the work that goes into them. Being able to run your code in a browser, or on a Raspberry Pi, or on a phone, or on a server, are real features that are added to the language, but they don&#39;t hurt its simplicity at all.
</p><p>I won&#39;t say too much more about this because hopefully you&#39;ll be able to see it as a little bit of a theme in the following sections.
</p><h3>Compile Times
</h3><p>A very fast iteration cycle is a very nice feature that simple languages aim for. Prototyping and experimentation is very cheap and the developer can stay in a flow-state that a 2+ second compile time would make impossible.
</p><p>Obviously, C needs a little bit of slack here, because it&#39;s designed as a single-pass compiler originally, but its design is quite good considering that constraint. Say what you will about header files being annoying, I think they&#39;re quite ergonomic under those circumstances. They offer an out-of-orderness that we take for granted now but that definitely counts as a ready-at-hand feature.
</p><p>But for Gleam and Go, compiler performance is some of the best in class. Go is famous for this, so I won&#39;t say too much about it. The Gleam compiler is written in Rust and the designers have been very explicit that it will never be self-hosted, as that would hurt compiler performance and make distribution harder. Files are parsed and processed in parallel where possible, and I&#39;ve personally found my Gleam projects to compile instantly.
</p><p>It&#39;s also worth mentioning gleam&#39;s dependency system is extremely nice. It works with the Hex package manager of Erlang and Elixir, and therefore generates beautiful HexDocs documentation pages for you to make libraries easy to find and make good documentation the norm. To see how convenient gleam makes everything, see the options that come up when I type <code>gleam</code> into my terminal and hit enter:
</p><pre><code> $ gleam

gleam 1.0.0

USAGE:
    gleam &lt;SUBCOMMAND&gt;

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    add        Add new project dependencies
    build      Build the project
    check      Type check the project
    clean      Clean build artifacts
    deps       Work with dependency packages
    docs       Render HTML documentation
    export     Export something useful from the Gleam project
    fix        Rewrite deprecated Gleam code
    format     Format source code
    help       Print this message or the help of the given subcommand(s)
    hex        Work with the Hex package manager
    lsp        Run the language server, to be used by editors
    new        Create a new project
    publish    Publish the project to the Hex package manager
    remove     Remove project dependencies
    run        Run the project
    shell      Start an Erlang shell
    test       Run the project tests
    update     Update dependency packages to their latest versions
</code></pre><p>That&#39;s a lot of very straightforward and convenient subcommands! I&#39;ve been using Gleam for a few months now and published a couple packages and added many to my projects and I&#39;m very happy with this process.
</p><h3>One Way of Doing Things
</h3><p>Designing a language for fast compile times often means a lot of fancy features aren&#39;t possible. For example, Go isn&#39;t planning on adding metaprogramming, and for a long time wasn&#39;t even planning on adding generics. 
</p><p>But in many cases these languages argue that the sacrifices made for performance are actually better language design choices anyway. Go wants all of its looping code to be with a for loop, all of its &quot;this-or-that&quot; code to be with if statements, and all of its &quot;choose-one-of-these&quot; code to be with switch statements. To that end, for loops and switch statements are a little unusual in Go, and there&#39;s no while loop. Go&#39;s concurrency story is very committed to one approach, unlike Rust which is the opposite. Functional code is possible to some degree but Go&#39;s lambdas are a pain in the ass to write.
</p><p>Gleam takes this idea even further. Following its functional lineage, there are <i>no</i> loop constructs, just recursion and things like <code>map</code> and <code>fold</code>. Tail call optimization is used so these compile a lot like how a while loop would. Furthermore, Gleam doesn&#39;t even have <code>if</code>! Instead, there is only (powerful) pattern matching with (powerful) guards. Fibonacci might be written like so:
</p><pre><code>pub fn fib(n: Int) -&gt; Int {
  case n &lt; 2 {
    True -&gt; n
    False -&gt; fib(n - 1) + fib(n - 2)
  }
}
</code></pre><p>Pattern matching on <code>True</code> and <code>False</code> is just like an <code>if</code> statement, so this &quot;limitation&quot; is never that annoying in practice.
</p><p>Gleam explicitly makes a small, synergystic feature set the goal, optimizing for fast <i>learning times</i> and ease of <i>reading code.</i> This focus is huge and definitely resonates with what I like about Go as well.
</p></div><div><div style="height:100pt;"></div><script src="https://storage.ko-fi.com/cdn/scripts/overlay-widget.js"></script><script>
  kofiWidgetOverlay.draw('ryanbrewer', {
    'type': 'floating-chat',
    'floating-chat.donateButton.text': 'Support me',
    'floating-chat.donateButton.background-color': '#323842',
    'floating-chat.donateButton.text-color': '#fff'
  });
    </script><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>