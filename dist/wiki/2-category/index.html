<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><link rel="stylesheet" href="/style.css"></head><body><div><script>
var _ARCTIC_C;
if (typeof HTMLDocument === 'undefined') HTMLDocument = Document;
let arctic_dom_content_loaded_listeners = [];
HTMLDocument.prototype.arctic_addEventListener = HTMLDocument.prototype.addEventListener;
HTMLDocument.prototype.addEventListener = function(type, listener, options) {
  if (type === 'DOMContentLoaded') {
    arctic_dom_content_loaded_listeners.push(listener);
    document.arctic_addEventListener(type, listener, options);
  } else document.arctic_addEventListener(type, listener, options);
}
       </script><div id="arctic-app"><div><div><title>2-Category - Ryan Brewer</title><meta name="description" content><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><script>hljs.highlightAll();</script></div><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Ryan Brewer</a><a href="/posts" id="nav-posts" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Posts</a><a href="/wiki" id="nav-wiki" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Wiki</a><a href="/contact" id="nav-contact" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Contact</a><a href="/demos" id="nav-demos" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Demos</a><a href="/feed.rss" id="nav-subscribe" onclick="window.location.href = &#39;/feed.rss&#39;"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>2-Category</h1><p><span>A 2-category is a <a href="/wiki/category"><span>category</span></a> \(C\) where the morphisms \(C(A,B)\) from one object \(A\) to another \(B\) form a category. That is, those morphisms are objects in some category, so there may be morphisms <i><span>between the morphisms!</span></i>
</span></p><p><span>We often include some notion of &quot;nontriviality&quot; (&quot;interesting-ness&quot;), because <i><span>any</span></i> set forms a category: the objects are the elements and the morphisms are strict equality. This is called a &quot;discrete&quot; category because there are no morphisms between objects, and indeed it&#39;s a fairly trivial (aka boring) category because the only arrows are identity arrows. So when we say that something is a 2-category we generally mean that the category formed by the elements of \(C(A,B)\) is a bit more interesting (aka nontrivial) in some way.
</span></p><p><span>Morphisms between morphisms in a 2-category are called 2-cells, regular morphisms are called 1-cells, and the objects are called 0-cells. 2-cells are often drawn like this:
</span></p><div class="diagram"><img src="/image-0-2-category.svg" onload="this.width *= 2.25;"></div><p><span>I often find that notation confusing, though, because it makes it seem like we just added some brand new thing to category theory, the arrows-between-arrows. In reality, it&#39;s just that there are two different categories, and one has some morphisms, and the other has those morphisms as its objects. So there&#39;s nothing fundamentally new going on here.
</span></p><p><span>Notice that 2-cells <i><span>don&#39;t</span></i> go across <a href="/wiki/homset"><span>homsets</span></a>. That is to say, they <i><span>cannot</span></i> do this:
</span></p><div class="diagram"><img src="/image-1-2-category.svg" onload="this.width *= 2.25;"></div><p><span>This is <i><span>not</span></i> a valid 2-cell! It crosses from \(C(X,Y)\) to \(C(Z,W)\), instead of staying in one or the other. 2-cells are <i><span>only</span></i> stuck within the same homset.
</span></p><p><span>The most famous 2-category is <a href="/wiki/cat"><span>\(\texttt{Cat}\)</span></a>, the category of <a href="/wiki/large-and-small-categories"><span>small categories</span></a>. The objects are small categories, the morphisms are <a href="/wiki/functor"><span>functors</span></a>, and the 2-cells are <a href="/wiki/natural-transformation"><span>natural transformations</span></a>.
</span></p><p><span>Obviously here it&#39;s a little silly to use the term &quot;homset,&quot; because we&#39;ve just established that these collections of morphisms are now categories, not sets. The term &quot;homcategory&quot; comes up sometimes, but 2-categories are an example of &quot;higher category,&quot; where you generally advance to the term &quot;<a href="/wiki/homset"><span>hom-object</span></a>.&quot; A hom-object is an object of some category, so small 1-categories have hom-objects in the category of sets \(\texttt{Set}\), and 2-categories have hom-objects in the category of categories \(\texttt{Cat}\). In higher category theory, we say that a category is &quot;enriched&quot; over the category of its hom-objects, so good ol&#39;-fashioned categories are \(\texttt{Set}\)-enriched, and 2-categories are \(\texttt{Cat}\)-enriched. Notice that \(\texttt{Set}\) is itself \(\texttt{Set}\)-enriched (enriched over itself!) and similarly \(\texttt{Cat}\) is \(\texttt{Cat}\)-enriched. It turns out that self-enrichment is just the same as having <a href="/wiki/exponential-object"><span>exponential objects</span></a>! It&#39;s worth taking a moment to think about why that is, because it&#39;s simple and satisfying.
</span></p><p><span>It&#39;s hopefully obvious that there are also 3-categories, 4-categories, and so on. These have 3-cells, 4-cells, etc. \(\infty\)-categories have no limit to the depth of arrows-between-arrows-between-etc. However, I&#39;m simplifying a lot here and they&#39;re a kind of fuzzy concept, meaning things get very technical and advanced when talking about them. It&#39;s beyond my category-theory level!
</span></p><p><span>Note that the category of 1-categories (which is \(\texttt{Cat}\)) is a 2-category; the category of 2-categories is a 3-category and this pattern continues indefinitely.</span></p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div></div><script>
// SPA algorithm partially inspired by Hayleigh Thompson's wonderful Modem library
async function go_to(url, loader, back) {
  if (!back && url.pathname === window.location.pathname) {
    if (url.hash) document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else window.scrollTo(0, 0);
    return;
  }
  document.dispatchEvent(new Event('beforeunload'));
  document.dispatchEvent(new Event('unload'));
  for (let i = 0; i < arctic_dom_content_loaded_listeners.length; i++)
    document.removeEventListener('DOMContentLoaded', arctic_dom_content_loaded_listeners[i]);
  arctic_dom_content_loaded_listeners = [];
  const $app = document.getElementById('arctic-app');
  if (loader) $app.innerHTML = '<div id="arctic-loader"></div>';
  if (!back) window.history.pushState({}, '', url.href);
  // handle new path
  const response = await fetch('/__pages/' + url.pathname + '/index.html');
  if (!response.ok) response = await fetch('/__pages/404.html');
  if (!response.ok) return;
  const html = await response.text();
  $app.innerHTML = '<script>_ARCTIC_C=0;</'+'script>'+html;
  // re-create script elements, so their javascript runs
  const scripts = $app.querySelectorAll('script');
  const num_scripts = scripts.length;
  for (let i = 0; i < num_scripts; i++) {
    const script = scripts[i];
    const n = document.createElement('script');
    // scripts load nondeterministically, so we figure out when they've all finished via the _ARCTIC_C barrier
    if (script.innerHTML === '') {
      // external scripts don't run their inline js, so they need an onload listener
      n.onload = () => {
        if (++_ARCTIC_C >= num_scripts)
          document.dispatchEvent(new Event('DOMContentLoaded'));
      };
    } else {
      // inline scripts might not trigger onload, so they get js appended to the end instead
      const t = document.createTextNode(
        script.innerHTML +
        ';if(++_ARCTIC_C>=' + num_scripts +
        ')document.dispatchEvent(new Event(\'DOMContentLoaded\'));'
      );
      n.appendChild(t);
    }
    // attributes at the end because 'src' needs to load after onload is listening
    for (let j = 0; j < script.attributes.length; j++) {
      const attr = script.attributes[j];
      n.setAttribute(attr.name, attr.value);
    }
    script.parentNode.replaceChild(n, script);
  }
  window.requestAnimationFrame(() => {
    if (url.hash)
      document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else
      window.scrollTo(0, 0);
  });
}
document.addEventListener('click', async function(e) {
  const a = find_a(e.target);
  if (!a) return;
  try {
    const url = new URL(a.href);
    const is_external = url.host !== window.location.host;
    if (is_external) return;
    event.preventDefault();
    go_to(url, false, false);
  } catch {
    return;
  }
});
window.addEventListener('popstate', (e) => {
  e.preventDefault();
  const url = new URL(window.location.href);
  go_to(url, false, true);
});
function find_a(target) {
  if (!target || target.tagName === 'BODY') return null;
  if (target.tagName === 'A') return target;
  return find_a(target.parentElement);
}</script></div></body></html>