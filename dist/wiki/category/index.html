<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><link rel="stylesheet" href="/style.css"></head><body><div><script>
var _ARCTIC_C;
if (typeof HTMLDocument === 'undefined') HTMLDocument = Document;
let arctic_dom_content_loaded_listeners = [];
HTMLDocument.prototype.arctic_addEventListener = HTMLDocument.prototype.addEventListener;
HTMLDocument.prototype.addEventListener = function(type, listener, options) {
  if (type === 'DOMContentLoaded') {
    arctic_dom_content_loaded_listeners.push(listener);
    document.arctic_addEventListener(type, listener, options);
  } else document.arctic_addEventListener(type, listener, options);
}
       </script><div id="arctic-app"><div><div><title>Category - Ryan Brewer</title><meta name="description" content><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><script>hljs.highlightAll();</script></div><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">â˜°</div><a href="/" id="nav-home" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Ryan Brewer</a><a href="/posts" id="nav-posts" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Posts</a><a href="/wiki" id="nav-wiki" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Wiki</a><a href="/contact" id="nav-contact" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Contact</a><a href="/demos" id="nav-demos" onclick="document.body.classList.remove(&#39;noscroll&#39;);">Demos</a><a href="/feed.rss" id="nav-subscribe" onclick="window.location.href = &#39;/feed.rss&#39;"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Category</h1><p><span>Informally, a category is just a collection of things, along with a particular relationship between these things. For example, imagine the collection of all possible states our world could be in (Einstein being the American president, dogs not existing, and any other wacky thing you can come up with). In any particular world \(W_1\), there are other worlds \(W_2\) that we can &quot;get to&quot; if some sequence of events were to occur, transforming \(W_1\) into \(W_2\). At the very least, every state can &quot;get to&quot; <i><span>itself</span></i> by &quot;doing nothing.&quot; For example, I can get from a world where I have an apple to a world where I don&#39;t by eating the apple, or giving it away, or throwing it in a lake, etc.
</span></p><p><span>Formally, a category \(C\) is a collection of objects (often written \(\texttt{ob}(C)\)) and a collection of arrows (often called &quot;morphisms,&quot; each starting at an object and ending at an object). To be a valid category, there are some requirements these collections need to satisfy. <i><span>It&#39;s very helpful to draw these on paper.</span></i> For any object \(X\) in \(C\), there must be a morphism from \(X\) to \(X\) (drawn as a little loop at \(X\)) that &quot;does nothing&quot; (typically written \(id_X\) or \(1_X\) but sometimes unfortunately written as just \(X\) when what is meant is &quot;clear from context&quot;). This is called an &quot;identity arrow,&quot; &quot;identity on \(X\),&quot; or &quot;identity of \(X\).&quot; Also, for any objects \(X\), \(Y\), and \(Z\) in \(C\), for any two morphisms \(f:X\to Y\) and \(g:Y\to Z\), there must be a morphism \(g\circ f:X\to Z\) (pronounced &quot;\(g\) after \(f\)&quot;) that is exactly the same as following \(f\) from \(X\) to \(Y\) and from there following \(g\) to finally get to \(Z\). This is called the <i><span>composition</span></i> of \(f\) and \(g\), and the composition operator \(\circ\) must be associative. These requirements are drawn formally with the following diagrams. These diagrams are called &quot;commutative diagrams&quot; or &quot;commuting diagrams,&quot; meaning that any two paths from one object to another must be equal (one says the diagram &quot;commutes&quot;). Therefore, each diagram is visually representing a bunch of equations, such as \(f\circ id_X=f\).
</span></p><div class="diagram"><img src="/image-0-category.svg" onload="this.width *= 2.25;"></div><div class="diagram"><img src="/image-1-category.svg" onload="this.width *= 2.25;"></div><div class="diagram"><img src="/image-2-category.svg" onload="this.width *= 2.25;"></div><p><span>These requirements aren&#39;t too difficult to satisfy; categories show up all over the place. Any transitive, reflexive relation (these are called &quot;preorders&quot;) gives rise to a category, including \(\leq\) on the integers. So for any integer, say \(7\), it&#39;s less than or equal to itself (\(7\leq 7\)). And for any three integers \(a\), \(b\), and \(c\), if \(a\leq b\) and \(b\leq c\), then \(a\leq c\). And of course, \(\leq\) is associative.
</span></p><p><span>You&#39;ll also find a category in any &quot;monoid,&quot; that is, an associative binary operation (like \(+\)) on a set (like the integers) which has a unit for the operation (like \(0\)). You can form a category with a single object \(M\) where the arrows all loop from \(M\) back to \(M\), representing the elements of the set (such as the integers). So for example, \(1:M\to M\), \(2:M\to M\), etc. \(M\) is called a &quot;monoid object.&quot; This is a proper category because any two of these arrows can be composed using the binary operation, which we&#39;ve required to be associative. For example, \(3+4:M\to M\). And there&#39;s an arrow for the unit (such as \(0\), for \(+\)) that behaves as the identity arrow of \(M\).
</span></p><p>*<span>Psst-- Draw those examples out on a sheet of paper! Show some example diagrams! It really helps ideas crystallize. Here&#39;s one:*
</span></p><div class="diagram"><img src="/image-3-category.svg" onload="this.width *= 2.25;"></div><p><span>It&#39;s been said in some category theory learning material that I can&#39;t find now that a category is something like a bridge between the definition of a preorder and the definition of a monoid, capturing each in a way that extends the other. This is an informal idea but I found it helpful. A preorder is a category with multiple objects but only one arrow (at most) between each object, and a monoid is a category with multiple arrows but only one object. Bartosz Milewski (a popular category theory educator) suggested that a category can also be seen as a &quot;proof-relevant&quot; preorder, meaning objects can be related to each other and themselves in multiple ways that are seen as distinct, as opposed to typical relations which either relate two given objects or don&#39;t.
</span></p><p><span>In programming, we typically use a slightly different-looking category. Namely, we typically use categories where the objects are types (or some similar collection, like sets) and the arrows are functions (or function-like in some way). That&#39;s why I&#39;ve been naming objects uppercase and naming morphisms starting from &quot;f.&quot; This particular kind of category has certain properties right out the gate. The &quot;relationships&quot; between objects aren&#39;t propositions (like \(4\leq 5\)) but <i><span>transformations</span></i> (like \(f(x)=x+1\)). We often have values <i><span>within</span></i> objects (since the objects are collections), which wouldn&#39;t make sense with an object like \(7\). That means there are multiple distinct values, like \(7\) or \(8\), that are different from each other but represented by the same object in the category (say, <code><span>int</span></code>). Category theory can&#39;t talk about these values directly (it can hardly say things about even the <i><span>objects,</span></i> as it generally uses morphisms for all reasoning) though if you have something like a singleton set \(S\) then the set of all functions from \(S\) to any set \(X\) is equivalent to the set \(X\) itself, and gives a way of talking about the elements of \(X\) in category theory. Categories where the objects are collections are <i><span>EXTREMELY</span></i> powerful, and it&#39;s the main reason we say a category has a &quot;collection&quot; of objects instead of a &quot;set;&quot; we&#39;d like to be able to construct categories where the objects are all the sets, and there&#39;s no set-of-all-sets so this category&#39;s objects don&#39;t form a set. Check out the page on <a href="/wiki/large-and-small-categories"><span>small and large categories</span></a> for more on this.
</span></p><p><span>I think these categories-of-collections are also very useful and underappreciated for analytic philosophers, which is why the first example category I gave was an analysis of possible worlds. That category is an example where objects have an enormous amount of information (the entire state of the world), and arrows are transformations (sequences of events).
</span></p><p><span>Small categories form a famous and powerful category called <a href="/wiki/cat"><span>Cat</span></a>.</span></p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">Â© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div></div><script>
// SPA algorithm partially inspired by Hayleigh Thompson's wonderful Modem library
async function go_to(url, loader, back) {
  if (!back && url.pathname === window.location.pathname) {
    if (url.hash) document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else window.scrollTo(0, 0);
    return;
  }
  document.dispatchEvent(new Event('beforeunload'));
  document.dispatchEvent(new Event('unload'));
  for (let i = 0; i < arctic_dom_content_loaded_listeners.length; i++)
    document.removeEventListener('DOMContentLoaded', arctic_dom_content_loaded_listeners[i]);
  arctic_dom_content_loaded_listeners = [];
  const $app = document.getElementById('arctic-app');
  if (loader) $app.innerHTML = '<div id="arctic-loader"></div>';
  if (!back) window.history.pushState({}, '', url.href);
  // handle new path
  const response = await fetch('/__pages/' + url.pathname + '/index.html');
  if (!response.ok) response = await fetch('/__pages/404.html');
  if (!response.ok) return;
  const html = await response.text();
  $app.innerHTML = '<script>_ARCTIC_C=0;</'+'script>'+html;
  // re-create script elements, so their javascript runs
  const scripts = $app.querySelectorAll('script');
  const num_scripts = scripts.length;
  for (let i = 0; i < num_scripts; i++) {
    const script = scripts[i];
    const n = document.createElement('script');
    // scripts load nondeterministically, so we figure out when they've all finished via the _ARCTIC_C barrier
    if (script.innerHTML === '') {
      // external scripts don't run their inline js, so they need an onload listener
      n.onload = () => {
        if (++_ARCTIC_C >= num_scripts)
          document.dispatchEvent(new Event('DOMContentLoaded'));
      };
    } else {
      // inline scripts might not trigger onload, so they get js appended to the end instead
      const t = document.createTextNode(
        script.innerHTML +
        ';if(++_ARCTIC_C>=' + num_scripts +
        ')document.dispatchEvent(new Event(\'DOMContentLoaded\'));'
      );
      n.appendChild(t);
    }
    // attributes at the end because 'src' needs to load after onload is listening
    for (let j = 0; j < script.attributes.length; j++) {
      const attr = script.attributes[j];
      n.setAttribute(attr.name, attr.value);
    }
    script.parentNode.replaceChild(n, script);
  }
  window.requestAnimationFrame(() => {
    if (url.hash)
      document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else
      window.scrollTo(0, 0);
  });
}
document.addEventListener('click', async function(e) {
  const a = find_a(e.target);
  if (!a) return;
  try {
    const url = new URL(a.href);
    const is_external = url.host !== window.location.host;
    if (is_external) return;
    event.preventDefault();
    go_to(url, false, false);
  } catch {
    return;
  }
});
window.addEventListener('popstate', (e) => {
  e.preventDefault();
  const url = new URL(window.location.href);
  go_to(url, false, true);
});
function find_a(target) {
  if (!target || target.tagName === 'BODY') return null;
  if (target.tagName === 'A') return target;
  return find_a(target.parentElement);
}</script></div></body></html>