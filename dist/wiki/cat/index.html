<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Cat - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script>  <script type="module" crossorigin src="/assets/style-55236cb7.js"></script>
  <link rel="stylesheet" href="/assets/style-4373fd41.css">
</head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Cat</h1><p>\(\texttt{Cat}\) is a large <a href="/wiki/category">category</a> where all small categories are its objects. This means that when you&#39;re doing some work with a small category, you&#39;re also working in \(\texttt{Cat}\), giving you arrows, between your category and other categories, that you can actually use to help with your reasoning. The arrows in \(\texttt{Cat}\) are called &quot;<a href="/wiki/functor">functors</a>,&quot; and they&#39;re functions (really <i>mappings,</i> in the event of a large or locally large category where they can&#39;t be functions) mapping objects of some category \(C\) into objects of some category \(D\), and mapping the arrows in \(C\) to arrows in \(D\).
</p><p>Functors also get an extra restriction: functors must preserve commuting diagrams. What this means is that composition and identity must be preserved: \(F(g\circ f)=Fg\circ Ff\) and \(F(id_X)=id_{FX}\). (Category theory doesn&#39;t do parentheses for applying mappings to things; \(Fg\) might be written \(F(g)\) in what you&#39;re used to.) That preservation condition is an important idea and worth thinking about a little, and hopefully will become more clear in the coming paragraphs. It makes functors a sort of homomorphisms, if you&#39;re familiar with group theory or related fields of abstract algebra. In more friendly language, functors are required to preserve the structure of a category. So if I have some diagram in my category \(C\) then a functor \(F:C\to D\) gives me a diagram in \(D\) that can be drawn in a very similar way: 
</p><div class="diagram"><img src="/image-0-cat.svg" onload="this.width *= 2.25;"></div><p>\(\texttt{Cat}\) has <a href="/wiki/exponential-object">exponential objects</a> too (objects representing arrows), called &quot;functor categories.&quot; Remember, the objects of \(\texttt{Cat}\) are categories, so exponential objects are categories. A functor category representing the arrows in \(\texttt{Cat}\) from a category \(C\) to a category \(D\) is written \([C,D]\) (or, in typical exponential notation, \(D^C\)). The objects in such a category are functors from \(C\) to \(D\). The arrows transform one functor to another, and are called &quot;<a href="/wiki/natural-transformation">natural transformations</a>.&quot; Similar to how functors are like functions with an extra restriction that makes them useful, natural transformations are transformations that satisfy a &quot;naturality condition,&quot; hence calling them &quot;natural.&quot; Formally, for two functors \(F,G:C\to D\), a natural transformation \(\alpha:F\Rightarrow G\) is a family of morphisms in \(D\) transforming &quot;outputs&quot; of \(F\) into &quot;outputs&quot; of \(G\). Namely, \(\alpha_X:FX\to GX\). The naturality condition that natural transformations must satisfy is depicted below as a diagram that must commute, and also illuminates how the transformation works:
</p><div class="diagram"><img src="/image-1-cat.svg" onload="this.width *= 2.25;"></div><p>That is, \(Gf\circ\alpha_X=\alpha_Y\circ Ff\). Note that this entire diagram takes place in \(D\), and the only mention of \(C\) are \(X\) and \(Y\), which are objects in \(C\).
</p><p>I&#39;ve heard many times that being able to talk about and study natural transformations is the original &quot;point&quot; of category theory. Note once more that natural transformations, transforming functors into other functors, aren&#39;t some new special feature we just added to category theory. They&#39;re just arrows in categories! Not only that, but their abstract meaning in a functor category is more concrete in the categories functors act on, where they are just families of arrows. In functional programming we&#39;re quite comfortable with families of morphisms: they&#39;re (parametrically) polymorphic functions! Indeed, it&#39;s been proven that a parametrically-polymorphic function <code>f&lt;T&gt;: F&lt;T&gt; -&gt; G&lt;T&gt;</code> (or, in a more Haskelly notation, <code>f :: F a -&gt; G a</code>) satisfies the naturality condition and and is a natural transformation if <code>F</code> and <code>G</code> are functors. So the abstract-ness of natural transformations gets concrete pretty quickly in, say, a language like Haskell.
</p><p>One of the main reasons natural transformations felt like arcane magic to me for a long time was that people often draw them as arrows between arrows, like so:
</p><div class="diagram"><img src="/image-2-cat.svg" onload="this.width *= 2.25;"></div><p>This makes it appear as though there&#39;s some new thing we&#39;re allowed to do with categories, while in reality a natural transformation is just another regular morphism in some category somewhere.
</p><p>Because \(\texttt{Cat}\) is enriched over \(\texttt{Cat}\), the arrows between two objects (categories) form a category, and we can say there are arrows between the arrows. That&#39;s what leads to the above notation of natural transformations as arrows between arrows. We call \(\texttt{Cat}\) a &quot;2-category&quot; because there are arrows between the arrows, the idea being that a set is only objects and is a &quot;0-category,&quot; and then adding arrows between objects is a &quot;1-category.&quot; If you have arrows between arrows between arrows then it&#39;s a 3-category. Note that the category of 1-categories (which is \(\texttt{Cat}\)) is a 2-category; the category of 2-categories is a 3-category and this pattern continues indefinitely. I&#39;m told advanced researchers are studying \(\infty\)-categories but we&#39;re well beyond what I know now!
</p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>