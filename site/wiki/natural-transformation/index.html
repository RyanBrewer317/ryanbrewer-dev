<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Natural Transformation - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">â˜°</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Natural Transformation</h1><p>A morphism in a <a href="/wiki/functor-category">functor category</a> is called a &quot;natural transformation.&quot; given two functors \(F:C\to D\) and \(G:C\to D\), a natural transformation \(\alpha:F\to G\) maps every object \(FX\) in \(D\) into some object \(GX\) in \(D\), such that following \(F\) and then \(\alpha\) is the same as following \(G\). There&#39;s an equation that must be satsified, called the &quot;naturality condition,&quot; which is why these transformations are called &quot;natural.&quot; Categories of functors could be thought of that had something else as arrows, but natural transformations are particularly useful, so we decide to define <a href="/wiki/cat">Cat</a> as having functor categories as exponential objects, instead of other imagineable categories of functors.
</p><p>Formally, for two functors \(F,G:C\to D\), a natural transformation \(\alpha:F\Rightarrow G\) is a family of morphisms in \(D\) transforming &quot;outputs&quot; of \(F\) into &quot;outputs&quot; of \(G\). Namely, \(\alpha_X:FX\to GX\). The naturality condition that natural transformations must satisfy is depicted below as a diagram that must commute, and also illuminates how the transformation works:
</p><div class="diagram"><img src="/image-0-natural-transformation.svg" onload="this.width *= 2.25;"></div><p>That is, \(Gf\circ\alpha_X=\alpha_Y\circ Ff\). Note that this entire diagram takes place in \(D\), and the only mention of \(C\) are \(X\) and \(Y\), which are objects in \(C\).
</p><p>I&#39;ve heard many times that being able to talk about and study natural transformations is the original &quot;point&quot; of category theory. Note once more that natural transformations, transforming functors into other functors, aren&#39;t some new special feature we just added to category theory. They&#39;re just arrows in categories! Not only that, but their abstract meaning in a functor category is more concrete in the categories functors act on, where they are just families of arrows. In functional programming we&#39;re quite comfortable with families of morphisms: they&#39;re (parametrically) polymorphic functions! Indeed, it&#39;s been proven that a parametrically-polymorphic function <code>f&lt;T&gt;: F&lt;T&gt; -&gt; G&lt;T&gt;</code> (or, in a more Haskelly notation, <code>f :: F a -&gt; G a</code>) satisfies the naturality condition and and is a natural transformation if <code>F</code> and <code>G</code> are functors. So the abstract-ness of natural transformations gets concrete pretty quickly in, say, a language like Haskell.
</p><p>One of the main reasons natural transformations felt like arcane magic to me for a long time was that people often draw them as arrows between arrows, like so:
</p><div class="diagram"><img src="/image-1-natural-transformation.svg" onload="this.width *= 2.25;"></div><p>This makes it appear as though there&#39;s some new thing we&#39;re allowed to do with categories, while in reality a natural transformation is just another regular morphism in some category somewhere. This notation does, however, help illustrate a complication with natural transformations: there are two different ways to compose them! &quot;Vertical&quot; composition is the kind you might expect:
</p><div class="diagram"><img src="/image-2-natural-transformation.svg" onload="this.width *= 2.25;"></div><p>But there&#39;s also &quot;horizontal&quot; composition, which I could draw either of two ways:
</p><div class="diagram"><img src="/image-3-natural-transformation.svg" onload="this.width *= 2.25;"></div><p></p><div class="diagram"><img src="/image-4-natural-transformation.svg" onload="this.width *= 2.25;"></div><p>This is a powerful form of composition that gets used a lot but one that took me a while to wrap my head around. A composition of functors \(H\circ F\) is just some functor out there, and so is \(K\circ G\). They may behave quite differently from \(H\) or \(F\) or \(K\) or \(G\). It seems strange that transformations from \(F\) to \(G\) and \(H\) to \(K\) would be enough to find a natural transformation between these two mysterious functors. But indeed they are! Consider the natural transformation written &quot;pointwise&quot; or &quot;by components:&quot; \(\gamma_X:H(FX)\to K(GX)\). (\(\gamma\) is what I&#39;m calling the natural transformation \(\beta\circ \alpha\).) If we think just for a moment for cases where objects are types and arrows are functions, this is a polymorphic function that takes a value of type <code>H (F a)</code> (using a Haskelly notation) and returns a value of type <code>K (G a)</code>. Available to us are two polymorphic functions <code>alpha: F a -&gt; G a</code> and <code>beta: H a -&gt; K a</code>. So we can define \(\gamma_X\) as <code>gamma hfa = beta (fmap alpha hfa)</code> in Haskell, or \(\gamma_X=\beta_X\circ H\alpha_X\) in category theory notation. You could have instead done \(\gamma_X=K\alpha_X\circ \beta_X\), and because of the naturality condition these two definitions are equal. So we define the horizontal composition \(\beta\circ\alpha=\gamma\).
</p><p>Now one last tricky thing is that if we have two ways to compose, is the following diagram potentially ambiguous?
</p><div class="diagram"><img src="/image-5-natural-transformation.svg" onload="this.width *= 2.25;"></div><p>We&#39;ve got a square of natural transformations here, and it&#39;s unclear if we horizontally compose into a column first and then vertically compose, or if we vertically compose into a row first and then horizontally compose. Luckily, the naturality condition of natural transformations guarantees that either way produces the same result! Either way you end up with the same \(K\circ F\to M\circ H\) natural transformation. This is called the Interchange Law, and it has some pretty cool consequences I&#39;ll get to in future posts.
</p><p>A popular example of natural transformations in a language like Haskell are monads. Note that my explanation here won&#39;t help much with understanding how to use monads in your code, I&#39;m just discussing the math. A monad is an endofunctor \(T:C\to C\) with two natural transformations \(\eta:id_C\Rightarrow T\) and \(\mu:T\circ T\Rightarrow T\). There are also some conditions to satisfy, but let&#39;s start by unpacking just that much! \(id_C\) is an identity arrow in \(\texttt{Cat}\), so it&#39;s a functor that maps every object and morphism in \(C\) into that same object or morphism. \(T\circ T\) is the composition of \(T\) with itself, which is a thing you can do when an arrow loops from an object back to the same object (remember, \(T\) is an endofunctor, aka a looping arrow in \(\texttt{Cat}\)). So we&#39;ve got three functors we&#39;re talking about here (\(id_C\), \(T\), and \(T\circ T\)) and two natural transformations to get between them. Now, the restrictions on these natural transformations are nicely illustrated in two commutating diagrams:
</p><div class="diagram"><img src="/image-6-natural-transformation.svg" onload="this.width *= 2.25;"></div><p></p><div class="diagram"><img src="/image-7-natural-transformation.svg" onload="this.width *= 2.25;"></div><p>Note that compositions in these arrows are compositions of natural transformations. In particular, they are <i>horizontal</i> compositions, which you can only really know by context. Recall that \(id_C\circ T=T\), so \(\eta\) transforms the implicit \(id_C\) into \(T\) and \(id_T\) (an identity arrow in the functor category \([C,C]\)) does nothing \(T\), so horizontally composed into \(\eta\circ id_T\) they transform \(T\) into \(T\circ T\). If the arrow were a <i>vertical</i> composition instead, then it would mean \(id_T\) would transform \(T\) into \(T\) and then you&#39;d do \(\eta\) on \(T\), which makes no sense because \(\eta:id_C\to T\) and isn&#39;t an arrow coming out of \(T\). In the second diagram, \(id_T\circ\mu:T\circ T\circ T\to T\circ T\) might be more clear when written as \(id_T\circ\mu:T\circ(T\circ T)\to T\circ T\), which is equal because composition is associative.
</p><p>Sometimes writing natural transformations as \(\alpha_X: FX\to GX\) instead of \(\alpha:F\to G\) clarifies what&#39;s going on, making it feel more concrete. Note that in Haskell we&#39;d write <code>return :: a -&gt; T a</code> for some monad <code>T</code> instead of \(\eta:id_C\to T\), because we write natural transformations as polymorphic functions <code>alpha :: F a -&gt; G a</code> and \(id_C\) applied to any type <code>a</code> is just equal to that same type <code>a</code>. And for \(\mu\) we have the polymorphic function <code>join :: T (T a) -&gt; T a</code> for any monad <code>T</code>.
</p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">Â© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>