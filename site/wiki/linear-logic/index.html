<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Linear Logic - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Linear Logic</h1><p>Linear logic, discovered by <a href="https://en.wikipedia.org/wiki/Jean-Yves_Girard">Jean-Yves Girard</a>, is most commonly thought of as logic where facts must be used exactly once: they can&#39;t go unmentioned, and they are &quot;used up&quot; after their first use. This gives a powerful way to reason about resource usage, and is a theoretical inspiration for Rust&#39;s resource safety checks. This view of linear logic, when framed this way, is obviously very informal and missing important details. But it also gives a fairly limiting view of the possibilities linear logic offers. In its full definition, it&#39;s a <i>generalization</i> of &quot;normal, ordinary, every-day&quot; logic (sometimes called &quot;persistent&quot; or &quot;structural&quot; logic when talked about in comparison to linear logic). That is, linear logic puts restrictions on reasoning, but offers &quot;escape-hatches&quot; to do any ordinary reasoning. This has the powerful effect of annotating your proofs with the places that traditional rules are used. The end result is a clearer picture of what we&#39;re actually doing in our reasoning, and a fairly wide range of theoretical benefits arise from that clarity.
</p><p>I&#39;ll start by thinking about linear logic from a logic perspective, instead of a computer science perspective. When studying logic, we generally have this concept of a context, written \(\Gamma\), holding all the facts we have available to us in a step of a proof. If \(\Gamma\) holds some fact \(A\), then from the facts of \(\Gamma\) we can <i>deduce</i> \(A\), since it&#39;s already one of those facts. This is written \(\Gamma\vdash A\), and pronounced &quot;Gamma entails A.&quot; These statements are called &quot;sequents.&quot; In ordinary logic, if you have \(\Gamma\vdash A\) and \(\Gamma\vdash B\), then it&#39;s possible to use the facts in \(\Gamma\) to prove the conjunction \(A\land B\), so we write the sequent \(\Gamma\vdash A\land B\). We often use a comma notation for contexts, like \(\Gamma,P\), to say &quot;any context \(\Gamma\), including an empty one, extended with the additional proposition \(P\).&quot;
</p><p>In ordinary logic, if we have some sequent \(\Gamma\vdash P\), we&#39;re allowed to add any facts we want to the context, if we prove them. Formally, if \(\Gamma\vdash A\) and \(\Gamma\vdash B\), we can use the &quot;weakening&quot; rule to conclude \(\Gamma,A\vdash B\), since we know \(A\) doesn&#39;t contradict \(\Gamma\). Weakening allows us to duplicate anything in the context as many times as we want, so the context doesn&#39;t lose any information as we progress through a proof. Facts can be used more than once.
</p><p>In ordinary logic, if we have the same thing duplicated in the context, we can throw out duplicates. Formally, if \(\Gamma,A,A\vdash B\), then we can use the &quot;contraction&quot; rule to conclude that \(\Gamma,A\vdash B\). That means that if a fact isn&#39;t necessary to prove something, we can throw it away. Facts can be used less than once.
</p><p>Linear logic can be described as the result of throwing away weakening and contraction. Then there&#39;s no way to duplicate or throw away statements in the context, so they have to get used or stay in the context til the end of the proof. This is what gives linear logic the &quot;use everything exactly once&quot; reputation: you can&#39;t use things more than once, and you can&#39;t use things less than once. Weakening and contraction are called &quot;structural&quot; rules, so linear logic is an example of a logic called &quot;substructural.&quot; Using a proposition in linear logic is called &quot;consuming&quot; it.
</p><p>Implication in linear logic is written \(A\unicode{8888} B\) and is pronounced &quot;lolli&quot; or &quot;the lollipop operator,&quot; which proves \(B\) in a way that uses \(A\) exactly once. Note that \(A\unicode{8888} B\) is <i>itself</i> a proposition that must be used exactly once.
</p><p>There are a lot of details to making that a coherent logic, though. For example, when you&#39;ve proven a conjunction \(A\land B\), you could use it to prove \(A\), but then the \(B\) vanishes. But, in other situations, we use both components of a conjunction. With disjunction there&#39;s the same situation: you can turn \(A\lor B\) into \(C\) with two implications \(A\Rightarrow C\) and \(B\Rightarrow C\), but can the context be used once per proof-of-implication, or do they have to &quot;share resources,&quot; with a usage in one preventing a usage in the other? One might say that using the context once each is duplicating the context, but remember that only one of the implications actually gets &quot;used,&quot; so sharing facts might make some disappear without getting used.
</p><p>The answer to these questions isn&#39;t to pick one way and stick with it, but instead of have <i>two different</i> conjunctions and <i>two different</i> disjunctions! I&#39;ll now go through them one by one.
</p><p>&quot;Additive conjunction,&quot; written \(A\&amp;B\) and pronounced &quot;with,&quot; allows you to prove \(A\) or \(B\), your choice, but not both. This gives the notion mentioned above, where \(A\land B\Rightarrow A\) &quot;drops&quot; a \(B\), lost to the infinite platonic abyss. The unit of conjunction is True, because \(True\land A\equiv A\) for any proposition \(A\); the unit of additive conjunction is called &quot;top,&quot; written \(\top\).
</p><p>&quot;Additive disjunction,&quot; written \(A\oplus B\) and pronounced &quot;plus,&quot; allows you to prove two implications \(A\unicode{8888} C,B\unicode{8888} C\) in a way where they each have full access to the context, because we know we will use only one of the implications for our final \(A\oplus B\unicode{8888} C\), we just don&#39;t know which. The unit for additive disjunction is \(0\).
</p><p>&quot;Multiplicative conjunction,&quot; written \(A\otimes B\) and pronounced &quot;tensor,&quot; allows you to prove <i>both</i> \(A\) and \(B\). Think of pattern-matching in a functional language, where this conjunction is a tuple. The unit of multiplicative conjunction is \(1\).
</p><p>Finally, &quot;multiplicative disjunction,&quot; written \(A\unicode{8523}B\) and pronounced &quot;par,&quot; requires that the two implications \(A\unicode{8888}C,B\unicode{8888}C\) used to prove \(A\unicode{8523}B\unicode{8888}C\) share resources, meaning they may both happen. This is often used in contexts where you don&#39;t know which side of the disjunction is true and you want to just pick the first one, knowing that you&#39;ll change your mind and go pack if some new information reveals that it was actually the second one. For example, \(A\unicode{8523}(\neg A)\) is perfectly valid, even if \(A\) is &quot;this turing machine halts,&quot; because you can assume it doesn&#39;t halt and change your mind if it actually halts. For this kind of thing to be allowed, it has to be okay for both implications to &quot;happen,&quot; so they share resources. The unit of multiplicative disjunction is called &quot;bottom,&quot; written \(\bot\).
</p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>