<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Advanced Typechecking for Stack-Based Languages - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="This post discusses the interesting typechecker of SaberVM, which uses a stack-based bytecode language with a powerful type system."><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer's Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../style.css';</script></head><body><nav><a href="/" id="nav-home">Ryan Brewer</a><a href="/search" id="nav-search">Posts</a><a href="/contact.html" id="nav-contact">Contact</a><a href="/demos.html" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Advanced Typechecking for Stack-Based Languages</h1><div class="date">February 18, 2024</div><p>It&#39;s been a while since I posted anything, because I&#39;ve been hard at work on SaberVM&#39;s <a href="https://github.com/RyanBrewer317/SaberVM">implementation</a> and a little lambda calculus <a href="https://github.com/RyanBrewer317/SaberLC">compiler</a> that targets SaberVM. I thought I should take the time to write a short post discussing one of the interesting aspects of my implementation, a performant typechecker for SaberVM&#39;s type system. As SaberVM uses a stack-based bytecode language, there isn&#39;t much out there on how to typecheck it. The best example I could find of a similar language was Web Assembly&#39;s typed stack-based bytecode, but that type system is extremely simple compared to SaberVM&#39;s.
</p><h3>Simple Stack-Based Typechecking
</h3><p>The basics of typechecking stack-based code is extremely simple and elegant. You could think of it as a form of abstract interpretation, if you&#39;re familiar with that idea. All you do is you have a stack at compile-time, specifically a stack of <i>types.</i> It&#39;s called the &quot;type stack.&quot; You run through each instruction in each function, and if you see, say, an <code>add_f64</code> instruction with a type of <code>(float64,float64)-&gt;float64</code>, then you pop two types off the type stack, confirm that they&#39;re <code>float64</code>, and then push a <code>float64</code> onto the type stack.
</p><p>What&#39;s beautiful about this process is how it mirrors program execution. But, instead of pushing and popping <i>values,</i> you push and pop the <i>types</i> of those values. If the type stack doesn&#39;t have enough types to pop off, then you know the run-time stack won&#39;t have enough <i>values</i> to pop off, which is now something that is caught at compile-time. If you pop the wrong type, then the run-time stack would have a value of the wrong type, so you have a type error, discovered at compile-time.
</p><p>But instead of being undecidable, like actually running the program would be, this typechecker runs in <i>linear time,</i> because of how it treats <i>control flow.</i> When you get to a jump point in either Web Assembly or SaberVM, you&#39;re jumping to a place which is expecting the type stack to look a certain way, and that fact is known at compile-time, and can be used to typecheck the jump itself. In Web Assembly, this is done with their structured control flow system: <code>if</code>/<code>else</code>, <code>while</code>, etc. (instead of arbitrary <code>goto</code>s). In SaberVM, this is instead done using the Continuation-Passing Style structure of the language, so all control flow is represented as function calls.
</p><p>That&#39;s all very pretty and everything, but it only allows for very simple type systems, where types themselves don&#39;t need to be <i>constructed.</i> In the scheme I just described, its unclear how one would, say, instantiate a polymorphic function with <code>(int64, int64-&gt;void)</code> or some other complex type. I mean, SaberVM has type polymorphism (universal and existential), region polymorphism, and (bounded) capability polymorphism. How do we get from here to there?
</p><h3>Advanced Stack-Based Typechecking
</h3><p>Where SaberVM diverges from Web Assembly is by introducing a <i>second</i> compile-time stack (called the &quot;compile-time stack&quot; :). This stack is exposed to the user through a bunch (about 20) of instructions that manipulate it. If you want to instantiate a polymorphic function call with the type <code>(int64, int64)</code>, then before the call you write the instructions <code>int64</code>, <code>int64</code>, <code>tuple 2</code>. <code>tuple n</code> is an instruction that pops <code>n</code> values off the compile-time stack (not the type stack) and pushes a tuple of those types onto the compile-time stack. (For memory safety, tuple types are a little more complex than this, but the point stands.) This way SaberVM can let you specify very complex types in the same way you write runtime code.
</p><p>Now when the typechecker sees an <code>add_f64</code> instruction, it does the same as before, pushing and popping from the type stack. But when it sees a compile-time instruction like <code>tuple n</code>, it pushes and pops from the compile-time stack instead, and then the compile-time instruction disappears. Where the type stack is like an abstract interpretation of the run-time stack, the compile-time stack is like its own run-time stack, but where all execution is at compile-time.
</p><p>The compile-time stack itself is &quot;dynamically typed&quot; in some sense, but the &quot;run-time&quot; for this stack is all at compile-time, so any errors here are still caught at compile-time. For example, there&#39;s no check that <code>tuple n</code> is always called when there are at least <code>n</code> types on the compile-time stack. Since <code>tuple n</code> is evaluated at compile-time, we can just wait for it to fail, and if it does then its a compile-time error. This is particularly significant since SaberVM has a reasonably powerful <i>kind</i> system too. Not like a kind-level lambda calculus (aka kind-polymorphism) or anything, but there are types, regions, capabilities, and representations, so there are a lot of ways to have a &quot;kind error,&quot; like by <code>req</code>-ing a representation instead of a type. Since the compile-time stack is just compile-time execution with these values, anything that could possibly go wrong here is caught at compile-time. And since there&#39;s no control flow for this compile-time language, everything takes linear time.
</p><p>To actually <i>use</i> this new compile-time stack, a few instructions manipulate <i>both</i> the compile-time stack and type stack. <code>req</code> pops a type off the compile-time stack and puts it at the end of the type stack (which really makes it a &quot;type VecDeque,&quot; to use the Rust term). This allows functions to specify &quot;arguments,&quot; that is, what they expect the top of the type stack to look like: each <code>req</code> in a function is recorded to know the full type of the function by the end, and ultimately typecheck function calls in other functions (or recursive ones). Other uses of the compile-time stack include what I mentioned earlier: polymorphic function calls pop their compile-time arguments from the compile-time stack (and perform the necessary substitutions in their type signature). One last notable example is <code>malloc</code>, which pops a type from the compile-time stack to know what its allocating and returning. There are many more uses of the compile-time stack in SaberVM&#39;s bytecode language; it&#39;s proven extremely useful, flexible, and ergonomic.
</p><h3>Benefits
</h3><p>This compile-time stack approach removes the upper bound on the power of the type specification language. With its own stack, there&#39;s no reason it couldn&#39;t be as powerful as the run-time language itself, a la dependent types. SaberVM doesn&#39;t use that power, in favor of faster typechecking and no need for user-provided proofs, but as a designer its nice to know how forward-compatible the typechecking system is with unpredictable extensions to the type system in the future. Hopefully no such extensions are needed, but SaberVM is still a young project, currently in the prototyping stage. This is very much a part of the design stage, so things can definitely change a lot.
</p><p>Another benefit is performance. SaberVM uses the fact that functions are in Continuation-Passing Style (that is, function calls are only the last instruction of functions, never earlier) for an extremely parallel algorithm: function types have no return type component to them, and all the compile-time instructions are before any <code>call</code> instructions. Therefore, SaberVM can get the type of each function without <i>any</i> knowledge of the types of other functions, by simply stopping when it gets to a call that calls a global function. Therefore, functions can be typechecked in parallel in any order. Once all the types are known, SaberVM goes through any calls to global (ie. not from a function parameter) functions and makes sure that those types are correct. This second pass is quick for each function call (functions aren&#39;t re-processed) and only happens for global function calls. Calling a parameter is very normal in Continuation-Passing Style code, so global function calls aren&#39;t as common as you&#39;d think anyway. The second pass is linear (big-O of N) in the number of global function calls, like how the first pass is linear in the size of the program, but both passes are trivial to parallelize; each iteration creates no information needed by future iterations. </p><p>Typechecking in a parallel way like this also makes the type errors trivially recoverable, see <a href="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html">this fantastic blog post</a> for more about that. 
</p><p>Lastly, the language is easy to compile to, for the same reasons stack-based bytecode always is. Type annotations are lowered in a recursive algorithm to make them in a sort of reverse-polish-notation form, and that Just Works™.
</p><h3>Conclusion
</h3><p>This was one of those ideas that I felt really proud of for some reason, even if it&#39;s basically just like Zig&#39;s <code>comptime</code>-based polymorphism but for stack-based bytecode. I don&#39;t know of any language that&#39;s doing anything like this. Having worked with the system for a while now, I&#39;m really really pleased with it.
</p><p>The main reference I have for prior work is <a href="https://binji.github.io/posts/webassembly-type-checking/">this</a> great article on Web Assembly&#39;s typechecker.
</p><p>If you&#39;re interested in this project and want to know more, I have another post about it <a href="https://ryanbrewer.dev/posts/announcing-svm.html">here</a>. If you&#39;re excited about SaberVM&#39;s future, consider starring it on <a href="https://github.com/RyanBrewer317/SaberVM">github</a> (which has a more in-depth description of the project), or even <a href="https://github.com/sponsors/RyanBrewer317">sponsoring</a> me or supporting me on <a href="https://ko-fi.com/ryanbrewer">ko-fi</a>!
</p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>