id: logic-in-types
name: The Core Idea of Modern Proof Assistants
date: 2023-11-16

@paragraph@
When I was first introduced to proof assistants like Coq, I thought it would be graduate-level material
that was way beyond what I could ever hope to understand. However, the essence of how they work is surprisingly simple,
and very beautiful.
@end@

@paragraph@
This post only assumes a light familiarity with functional programming. 
However, a little familiarity with dependent types and proof assistants like Agda or Coq will help.
@end@

@paragraph@
There is a well-known correspondence between logic and type systems,
called the Curry-Howard Isomorphism. 
Basically, if a type has a value in it,
then it's "true," and if it's empty, it's "false." 
So "void" is false and "int" is true, for example.
@end@

@paragraph@
Structs (pairs, records, etc.) only have values if all the component types have values:
"struct{void a, int b}" is a type with no values, for example.
This gets us a way to express logical "and."
Enums (tagged unions, etc.) have values if any of the component types have values:
"enum{void a, int b}" has values, integers tagged with "b", for example.
This gets us a way to express logical "or."
Functions (pure, side-effect-free ones that is) operate like implication: 
if the input type has values, then the function can construct a value of the output type.
So "int -> void" is a type with no values, because any such values would be able to construct elements of "void."
Logical negation is simply represented by a function returning "void," because
"not p" and "p implies false" are equivalent.
This logic also doesn't have "p or not p" as an axiom. It is "intuitionistic."
@end@

@paragraph@
Is this useful? Yes, it's proven its worth. 
Because the correspondence is about types having values, you can make sure functions are
only called under the right conditions. 
Simply add a parameter to the function whose type corresponds to the precondition. 
Then the function can't be called unless a value (called a "proof") of that type is given.
In other words, it can only be called if the type is "true."
The classic example is something like, for a list of integers, "int get(int[] l, int i, 0<=i<length(l) p)".
This function is called with three arguments: an int[], an int, and a 0<=i<length(l).
@end@

@paragraph@
The correspondence I described above doesn't tell you how to construct the type "0<=i<length(l)."
This is where dependent types come in.
@end@

@paragraph@
Dependent function types are function types where the type of the output can refer to values of the input types.
Extending this to the setting of multiple-argument functions, it also means that input types can refer to the given values of earlier parameters.
The "get" function above is a dependent function, because the "0<=i<length(l)" refers to the earlier parameters i and l.
This type is really "struct{0<=i proof1, i<length(l) proof2}," since it's a logical "and."
The <= and < operators here are definable functions, which take integers as arguments and produce types.
So "get" can be called only if a struct can be constructed with two fields that respectively satisfy these two inequalities.
@end@

@paragraph@
Dependent function types have another use here, which is that they're the main way people represent logic's "forall" quantifier.
That is, if your proposition is "forall n: int, n < 5 implies n < 6" or something like that, you generally use a dependent function type.
The type would be something like "(n: int)->(n < 5)->(n < 6)." 
Note that this notation assigns a parameter name to the first parameter type so later types can refer to it.
This works like "forall" because functions of this type can only be constructed if *every possible result type* has a value.
In the case of "(n: int)->(n < 5)->(n < 6)", a value of this type *can* be created, because proving that n is less than 5 is sufficient to prove that it is less than 6.
If the type were instead "(n: int)->(n > 5)->(n > 6)", and we call this function f, 
then it could be called like "f(6)(proof_6_gt_5)" which are all valid terms, and then you'd have a proof that 6 > 6, which is a contradiction.
Thus this function f can't exist. 
So dependent function types let you express "forall" in type theory, which is quite powerful.
@end@