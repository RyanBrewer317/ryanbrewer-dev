<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Search Wiki - Ryan Brewer - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="Look through Ryan&#39;s personal wiki"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../style.css';</script><script>const WIKIS = {"cat": {"id": "cat", "url": "/posts/cat", "title": "", "tags": ["cat", "category", "categories", "functor", "functors", "natural", "transformation", "transformations"]},
"category": {"id": "category", "url": "/posts/category", "title": "", "tags": ["category", "categories", "theory", "object", "objects", "arrow", "arrows", "morphism", "morphisms"]},
"exponential-object": {"id": "exponential-object", "url": "/posts/exponential-object", "title": "", "tags": ["exponential", "object", "objects", "category", "categories", "arrow", "arrows", "morphism", "morphisms", "function", "functions", "type", "types"]},
"first-wiki": {"id": "first-wiki", "url": "/posts/first-wiki", "title": "", "tags": ["first wiki"]},
"functor-category": {"id": "functor-category", "url": "/posts/functor-category", "title": "", "tags": ["functor", "functors", "category", "categories", "theory", "natural", "transformation", "transformations", "exponential", "object", "cat"]},
"functor": {"id": "functor", "url": "/posts/functor", "title": "", "tags": ["category", "cat", "categories", "bifunctor", "functoriality", "bifunctoriality", "functors", "bifunctors", "homomorphism", "homomorphisms", "structure", "preserving", "theory"]},
"linear-logic": {"id": "linear-logic", "url": "/posts/linear-logic", "title": "", "tags": ["girard", "resource", "substructural", "affine", "relevant", "resources", "category", "theory", "monoid", "monoidal", "string", "star", "autonomous", "star-autonomous", "*-autonomous", "categories", "once"]},
"monoidal-category": {"id": "monoidal-category", "url": "/posts/monoidal-category", "title": "", "tags": ["monoid", "monoidal", "category", "categories", "string", "diagram", "diagrams", "bicategory", "bicategories", "2-category", "2-categories", "bifunctor"]},
"natural-isomorphism": {"id": "natural-isomorphism", "url": "/posts/natural-isomorphism", "title": "", "tags": ["natural", "transformation", "transformations", "functor", "category", "isomorphism"]},
"natural-transformation": {"id": "natural-transformation", "url": "/posts/natural-transformation", "title": "", "tags": ["natural", "transformation", "naturality", "transformations", "functor", "cat", "functors", "theory", "categories", "category", "2-category", "2-cell", "2-morphism"]},
};</script><script>
function searchWikisKeyUp() {
  // Declare variables
  const $input = document.getElementById("search-wiki");
  const q = $input.value.toLowerCase();
  const $menu = document.getElementById("search-wiki-menu");
  $menu.replaceChildren(...Array.from($menu.children).sort((a, b) => {
    const aHits = getHits(q, WIKIS[a.id]);
    const bHits = getHits(q, WIKIS[b.id]);
    return bHits - aHits;
  }));
}
function getHits(q, w) {
  let hits = 0;
  for (const i in w.tags) if (q.includes(w.tags[i])) hits += 2;
  return hits;
}
  </script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><input type="text" id="search-wiki" placeholder="Search..." onkeyup="searchWikisKeyUp()" title="Enter search terms"><ul id="search-wiki-menu"><li id="cat" class="wiki-thumbnail"><h3><a href="../wiki/cat"></a></h3><div><span>\(\texttt{Cat}\) is a large [/wiki/category](category) where all small categories are its objects. This means that when you&#39;re doing some work with a small category, you&#39;re also working in \(\texttt{Cat}\), giving you arrows, between your category and other categories, that you can actually use to help with your reasoning. The arrows in \(\texttt{Cat}\) are called &quot;[/wiki/functor](functors),&quot; and they&#39;re functions (really *mappings,* in the event of a large or locally large category where they can&#39;t be functions) mapping objects of some category \(C\) into objects of some category \(D\), and mapping the arrows in \(C\) to arrows in \(D\).<br></span></div></li><li id="category" class="wiki-thumbnail"><h3><a href="../wiki/category"></a></h3><div><span>Informally, a category is just a collection of things, along with a particular relationship between these things. For example, imagine the collection of all possible states our world could be in (Einstein being the American president, dogs not existing, and any other wacky thing you can come up with). In any particular world \(W_1\), there are other worlds \(W_2\) that we can &quot;get to&quot; if some sequence of events were to occur, transforming \(W_1\) into \(W_2\). At the very least, every state can &quot;get to&quot; *itself* by &quot;doing nothing.&quot; For example, I can get from a world where I have an apple to a world where I don&#39;t by eating the apple, or giving it away, or throwing it in a lake, etc.<br></span></div></li><li id="exponential-object" class="wiki-thumbnail"><h3><a href="../wiki/exponential-object"></a></h3><div><span>In many cases, the arrows of a [/wiki/category](category) will also have some representation as objects in that same category. For example, in a category of sets and functions, functions are also sets, so may be present as both arrows and objects in the category. Categories where *every* arrow has a corresponding object are called &quot;closed,&quot; though this adjective doesn&#39;t appear by itself because there are several types of &quot;closed:&quot; &quot;monoidal closed,&quot; &quot;cartesian closed,&quot; and other&#39;s; I&#39;ll discuss them in a moment. The object of an arrow \(f:X\to Y\) is called an &quot;exponential&quot; or &quot;exponential object&quot; and is written \(Y^X\). This notation comes from the idea that if \(X\) and \(Y\) are sets, the number of elements (functions) in the set \(X\to Y\) is equal to the number of elements in \(Y\) raised to the power of the number of elements in \(X\), which is kinda fun I think.<br></span></div></li><li id="first-wiki" class="wiki-thumbnail"><h3><a href="../wiki/first-wiki"></a></h3><div><span>This is my first wiki page! It&#39;s mostly to test out the codebase.<br></span></div></li><li id="functor-category" class="wiki-thumbnail"><h3><a href="../wiki/functor-category"></a></h3><div><span>For any two objects ([/wiki/category](categories)) \(C\) and \(D\) in [/wiki/cat](Cat), the collection of morphisms ([/wiki/functor](functors)) from \(C\) to \(D\) form a category called a &quot;functor category,&quot; written \([C,D]\). This is an [/wiki/exponential-object](exponential object) in \(\texttt{Cat}\), so it might also be written \(D^C\). The objects in a functor category are functors from \(C\) to \(D\). The arrows are [/wiki/natural-transformation](natural transformations), which transform one functor into another.<br></span></div></li><li id="functor" class="wiki-thumbnail"><h3><a href="../wiki/functor"></a></h3><div><span></span></div></li><li id="linear-logic" class="wiki-thumbnail"><h3><a href="../wiki/linear-logic"></a></h3><div><span>Linear logic, discovered by [https://en.wikipedia.org/wiki/Jean-Yves_Girard](Jean-Yves Girard), is most commonly thought of as logic where facts must be used exactly once: they can&#39;t go unmentioned, and they are &quot;used up&quot; after their first use. This gives a powerful way to reason about resource usage, and is a theoretical inspiration for Rust&#39;s resource safety checks. This view of linear logic, when framed this way, is obviously very informal and missing important details. But it also gives a fairly limiting view of the possibilities linear logic offers. In its full definition, it&#39;s a *generalization* of &quot;normal, ordinary, every-day&quot; logic (sometimes called &quot;persistent&quot; or &quot;structural&quot; logic when talked about in comparison to linear logic). That is, linear logic puts restrictions on reasoning, but offers &quot;escape-hatches&quot; to do any ordinary reasoning. This has the powerful effect of annotating your proofs with the places that traditional rules are used. The end result is a clearer picture of what we&#39;re actually doing in our reasoning, and a fairly wide range of theoretical benefits arise from that clarity.<br></span></div></li><li id="monoidal-category" class="wiki-thumbnail"><h3><a href="../wiki/monoidal-category"></a></h3><div><span>A monoidal category is a [/wiki/category](category) \(C\) with a bifunctor \(\otimes:C\times C\to C\) and an object \(I\) such that \(\otimes\) is associative and \(I\otimes X=X=X\otimes I\) for any object \(X\) in \(C\). \(\otimes\) is called the &quot;tensor product.&quot; Well, that&#39;s just a *strict* monoidal category; monoidal categories, on the other hand, only need these equations to be isomorphisms. This means they additionally have three [/wiki/natural-isomorphism](natural isomorphisms): an &quot;associator&quot; \(\alpha_{X,Y,Z}:X\otimes(Y\otimes Z)\cong(X\otimes Y)\otimes Z\), a &quot;left unitor&quot; \(\lambda_X:I\otimes X\cong X\), and a &quot;right unitor&quot; \(\rho_X:X\otimes I\cong X\). These have to satisfy two coherence conditions.<br></span></div></li><li id="natural-isomorphism" class="wiki-thumbnail"><h3><a href="../wiki/natural-isomorphism"></a></h3><div><span>Given two [/wiki/functor](functors) \(F:C\to D\) and \(G:C\to D\), a &quot;natural isomorphism&quot; between them \(\alpha: F\cong G\) is an isomorphism in the [/wiki/functor-category](functor category) \([C,D]\). Then \(F\) and \(G\) are called &quot;naturally isomorphic.&quot;<br></span></div></li><li id="natural-transformation" class="wiki-thumbnail"><h3><a href="../wiki/natural-transformation"></a></h3><div><span>A morphism in a [/wiki/functor-category](functor category) is called a &quot;natural transformation.&quot; given two [/wiki/functor](functors) \(F:C\to D\) and \(G:C\to D\), a natural transformation \(\alpha:F\to G\) maps every object \(FX\) in \(D\) into some object \(GX\) in \(D\), such that following \(F\) and then \(\alpha\) is the same as following \(G\). There&#39;s an equation that must be satsified, called the &quot;naturality condition,&quot; which is why these transformations are called &quot;natural.&quot; Categories of functors could be constructed that had something else as arrows, but the naturality condition can be derived from the construction of [/wiki/exponential-object](exponential objects) and the fact that \(\texttt{Cat}\)&#39;s morphisms are functorial, so it&#39;s a particularly fundamental condition, not to mention immensely useful.<br></span></div></li></ul></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>