<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Ryan Brewer&#39;s Blog - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="The place Ryan writes his thoughts and shows off SaberVM and other cool projects."><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><link rel="stylesheet" href="/style.css"></head><body><div><script>
var _ARCTIC_C;
if (typeof HTMLDocument === 'undefined') HTMLDocument = Document;
let arctic_dom_content_loaded_listeners = [];
HTMLDocument.prototype.arctic_addEventListener = HTMLDocument.prototype.addEventListener;
HTMLDocument.prototype.addEventListener = function(type, listener, options) {
  if (type === 'DOMContentLoaded') {
    arctic_dom_content_loaded_listeners.push(listener);
    document.arctic_addEventListener(type, listener, options);
  } else document.arctic_addEventListener(type, listener, options);
}
       </script><div id="arctic-app"><div><title>Functor - Ryan Brewer</title><meta name="description" content><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe" onclick="window.location.href = &#39;/feed.rss&#39;"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Functor</h1><p><span>A morphism in <a href="/wiki/cat"><span>Cat</span></a> is called a &quot;functor.&quot; A functor is a mapping objects of some category \(C\) into objects of some category \(D\), and mapping the arrows in \(C\) to arrows in \(D\). There is additionally a condition that must be satisfied called &quot;functoriality,&quot; which is that composition and identities are preserved: \(F(g\circ f)=Fg\circ Ff\), and \(F(id_X)=id_{FX}\). This leads some to call functors a &quot;homomorphism of categories,&quot; if you&#39;re familiar with abstract algebra.
</span></p><p><span>(Category theory doesn&#39;t do parentheses for applying mappings to things; \(Fg\) might be written \(F(g)\) in what you&#39;re used to.)
</span></p><p><span>So if I have some diagram in my category \(C\) then a functor \(F:C\to D\) gives me a diagram in \(D\) that can be drawn in a very similar way: 
</span></p><div class="diagram"><img src="/image-0-functor.svg" onload="this.width *= 2.25;"></div><p><span>This does <i><span>not</span></i> mean that if \(X\), \(Y\), and \(Z\) are different from each other, then \(FX\), \(FY\), and \(FZ\) are too. It <i><span>only</span></i> means that, assuming the first diagram commutes, the second one does too. \(FX\) could be equal to \(FY\), and \(Fp\) could even just be \(id_{FX}\)! So long as commuting diagrams are mapped to diagrams that also commute. One example of a functor that I like is from the monoid-based category of addition on natural numbers to the monoid-based category of multiplication on natural numbers. The single monoid object gets mapped into the other single monoid object, of course. There are a bunch of functors to choose from here, but I like powers of 2 so I&#39;ll map every morphism \(n\) in the addition category to the morphism \(2^n\) in the multiplication category. That&#39;s a functor because if I compose two morphisms in the addition category (say, \(2+3\)) then does the right thing in the multiplication category. Functors are often written with a dash in the place of the parameter, so this functor would be written \(2^-\). Here&#39;s a diagram to help illustrate:
</span></p><div class="diagram"><img src="/image-1-functor.svg" onload="this.width *= 2.25;"></div><p><span>This represents how exponentiation turns multiplication into addition! Composition in these categories are addition and multiplication respectively, and the functor is raising 2 to a power, so the functors-preserve-composition equation \(F(g\circ f)=Fg\circ Ff\) becomes \(2^{n+m}=2^ncdot 2^m\), a rule for exponentials we learn in high school!
</span></p><p><span>I find it helpful to remember that functors are just arrows in \(\texttt{Cat}\). They&#39;re just transformations from collections of objects and morphisms to other collections of objects and morphisms, and we&#39;ve attached a restriction to them that we&#39;ve found useful and commonly-satisfied. A category of all small categories could be created where the arrows aren&#39;t functors, and functors aren&#39;t some new axiomatic thing in category theory. It&#39;s still all just objects and arrows, and functors are just an example of morphisms. They just feel different when we use them because we&#39;re not working in \(\texttt{Cat}\) but <i><span>within some object</span></i> in \(\texttt{Cat}\), so the arrows of \(\texttt{Cat}\) have a sort of strange (but useful!) effect.
</span></p><p><span>In programming we often deal with categories of collections. So an object (say, a set) contains elements within it. It&#39;s very important to keep in mind that functors just map objects to objects and can&#39;t touch the elements within at all. A functor might map the set \(\{4\}\) to the empty set \(\{\}\), and note that there isn&#39;t any function from \(\{4\}\) to the empty set, since there&#39;s no way to transform \(4\) into nothing! The real function is on the collections of objects (and morphisms), of which \(\{4\}\) and \(\{\}\) are just regular old members. This fact makes functors useful in programming. An &quot;endofunctor&quot; is a looping morphism in \(\texttt{Cat}\), so it goes from a category back to the same category. A popular example in programming is the List functor, which maps any type <code><span>T</span></code> into the type of lists whose elements are of type <code><span>T</span></code>, called something like <code><span>List&lt;T&gt;</span></code>. Again, <code><span>T</span></code> could be <code><span>void</span></code> and this mapping is still perfectly fine, because we&#39;re just transforming types, not the values of those types. <code><span>List&lt;void&gt;</span></code> is a perfectly valid type and has exactly one value, namely <code><span>[]</span></code>. The List functor maps morphisms (functions) \(f:T\to U\) to \(\texttt{map}\;f:\texttt{List}\;T\to\texttt{List}\;U\), functions which apply \(f\) to each element in the list to produce a new list. That&#39;s something we do a lot in functional programming and I think that&#39;s awesome!
</span></p><p><span>For any two categories \(C\) and \(D\) in \(\texttt{Cat}\), the collection of morphisms between them forms a category called a &quot;<a href="/wiki/functor-category"><span>functor category</span></a>,&quot; written \([C,D]\). This being an object in \(\texttt{Cat}\) itself, it&#39;s an <a href="/wiki/exponential-object"><span>exponential object</span></a>. The morphisms in a functor category are called <a href="/wiki/natural-transformation"><span>natural transformations</span></a>.
</span></p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div></div><script>
// SPA algorithm stolen from Hayleigh Thompson's wonderful Modem library
async function go_to(url, loader, back) {
  if (!back && url.pathname === window.location.pathname) {
    if (url.hash) document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else window.scrollTo(0, 0);
    return;
  }
  document.dispatchEvent(new Event('beforeunload'));
  document.dispatchEvent(new Event('unload'));
  for (let i = 0; i < arctic_dom_content_loaded_listeners.length; i++)
    document.removeEventListener('DOMContentLoaded', arctic_dom_content_loaded_listeners[i]);
  arctic_dom_content_loaded_listeners = [];
  const $app = document.getElementById('arctic-app');
  if (loader) $app.innerHTML = '<div id="arctic-loader"></div>';
  if (!back) window.history.pushState({}, '', url.href);
  // handle new path
  const response = await fetch('/__pages/' + url.pathname + '/index.html');
  if (!response.ok) response = await fetch('/__pages/404.html');
  if (!response.ok) return;
  const html = await response.text();
  $app.innerHTML = '<script>_ARCTIC_C=0;</'+'script>'+html;
  // re-create script elements, so their javascript runs
  const scripts = $app.querySelectorAll('script');
  const num_scripts = scripts.length;
  for (let i = 0; i < num_scripts; i++) {
    const script = scripts[i];
    const n = document.createElement('script');
    n.setAttribute('defer', 'true');
    if (script.innerHTML === '') n.onload = 
      () => {
        console.log('script',_ARCTIC_C);
        if(++_ARCTIC_C>=num_scripts)document.dispatchEvent(new Event('DOMContentLoaded'));
      };
      //(n.onload || '') + 
      //';if(++_ARCTIC_C>=' +
      //num_scripts +
      //')document.dispatchEvent(new Event(\'DOMContentLoaded\'));';
    else {
      const t = document.createTextNode(
        script.innerHTML +
        ';console.log(\'script\',_ARCTIC_C);' +
        'if(++_ARCTIC_C>=' + num_scripts +
        ')document.dispatchEvent(new Event(\'DOMContentLoaded\'));'
      );
      n.appendChild(t);
    }
    for (let j = 0; j < script.attributes.length; j++) {
      const attr = script.attributes[j];
      n.setAttribute(attr.name, attr.value);
    }
    script.parentNode.replaceChild(n, script);
  }
  window.requestAnimationFrame(() => {
    if (url.hash)
      document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else
      window.scrollTo(0, 0);
  });
  // setTimeout(() => document.dispatchEvent(new Event('DOMContentLoaded')), 100); // i cri ),x
}
document.addEventListener('click', async function(e) {
  const a = find_a(e.target);
  if (!a) return;
  try {
    const url = new URL(a.href);
    const is_external = url.host !== window.location.host;
    if (is_external) return;
    event.preventDefault();
    go_to(url, false, false);
  } catch {
    return;
  }
});
window.addEventListener('popstate', (e) => {
  e.preventDefault();
  const url = new URL(window.location.href);
  go_to(url, false, true);
});
function find_a(target) {
  if (!target || target.tagName === 'BODY') return null;
  if (target.tagName === 'A') return target;
  return find_a(target.parentElement);
}</script></div></body></html>