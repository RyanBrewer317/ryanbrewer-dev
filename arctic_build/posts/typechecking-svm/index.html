<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Advanced Typechecking for Stack-Based Languages - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="This post discusses the interesting typechecker of SaberVM, which uses a stack-based bytecode language with a powerful type system."><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><link rel="stylesheet" href="/style.css"></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1>Advanced Typechecking for Stack-Based Languages</h1><div class="date">February 1, 2024</div><p><span>It&#39;s been a while since I posted anything, because I&#39;ve been hard at work on SaberVM&#39;s <a src="https://github.com/RyanBrewer317/SaberVM"><span>implementation</span></a> and a little lambda calculus <a src="https://github.com/RyanBrewer317/SaberLC"><span>compiler</span></a> that targets SaberVM. I thought I should take the time to write a short post discussing one of the interesting aspects of my implementation, a performant typechecker for SaberVM&#39;s type system. As SaberVM uses a stack-based bytecode language, there isn&#39;t much out there on how to typecheck it. The best example I could find of a similar language was Web Assembly&#39;s typed stack-based bytecode, but that type system is extremely simple compared to SaberVM&#39;s.
</span></p><h3><span>Simple Stack-Based Typechecking
</span></h3><p><span>The basics of typechecking stack-based code is extremely simple and elegant. You could think of it as a form of abstract interpretation, if you&#39;re familiar with that idea. All you do is you have a stack at compile-time, specifically a stack of <i><span>types.</span></i> It&#39;s called the &quot;type stack.&quot; You run through each instruction in each function, and if you see, say, an <code><span>add_f64</span></code> instruction with a type of <code><span>(float64,float64)-&gt;float64</span></code>, then you pop two types off the type stack, confirm that they&#39;re <code><span>float64</span></code>, and then push a <code><span>float64</span></code> onto the type stack.
</span></p><p><span>What&#39;s beautiful about this process is how it mirrors program execution. But, instead of pushing and popping <i><span>values,</span></i> you push and pop the <i><span>types</span></i> of those values. If the type stack doesn&#39;t have enough types to pop off, then you know the run-time stack won&#39;t have enough <i><span>values</span></i> to pop off, which is now something that is caught at compile-time. If you pop the wrong type, then the run-time stack would have a value of the wrong type, so you have a type error, discovered at compile-time.
</span></p><p><span>But instead of being undecidable, like actually running the program would be, this typechecker runs in <i><span>linear time,</span></i> because of how it treats <i><span>control flow.</span></i> When you get to a jump point in either Web Assembly or SaberVM, you&#39;re jumping to a place which is expecting the type stack to look a certain way, and that fact is known at compile-time, and can be used to typecheck the jump itself. In Web Assembly, this is done with their structured control flow system: <code><span>if</span></code>/<code><span>else</span></code>, <code><span>while</span></code>, etc. (instead of arbitrary <code><span>goto</span></code>s). In SaberVM, this is instead done using the Continuation-Passing Style structure of the language, so all control flow is represented as function calls.
</span></p><p><span>That&#39;s all very pretty and everything, but it only allows for very simple type systems, where types themselves don&#39;t need to be <i><span>constructed.</span></i> In the scheme I just described, its unclear how one would, say, instantiate a polymorphic function with <code><span>(int64, int64-&gt;void)</span></code> or some other complex type. I mean, SaberVM has type polymorphism (universal and existential), region polymorphism, and (bounded) capability polymorphism. How do we get from here to there?
</span></p><h3><span>Advanced Stack-Based Typechecking
</span></h3><p><span>Where SaberVM diverges from Web Assembly is by introducing a <i><span>second</span></i> compile-time stack (called the &quot;compile-time stack&quot; :). This stack is exposed to the user through a bunch (about 20) of instructions that manipulate it. If you want to instantiate a polymorphic function call with the type <code><span>(int64, int64)</span></code>, then before the call you write the instructions <code><span>int64</span></code>, <code><span>int64</span></code>, <code><span>tuple 2</span></code>. <code><span>tuple n</span></code> is an instruction that pops <code><span>n</span></code> values off the compile-time stack (not the type stack) and pushes a tuple of those types onto the compile-time stack. (For memory safety, tuple types are a little more complex than this, but the point stands.) This way SaberVM can let you specify very complex types in the same way you write runtime code.
</span></p><p><span>Now when the typechecker sees an <code><span>add_f64</span></code> instruction, it does the same as before, pushing and popping from the type stack. But when it sees a compile-time instruction like <code><span>tuple n</span></code>, it pushes and pops from the compile-time stack instead, and then the compile-time instruction disappears. Where the type stack is like an abstract interpretation of the run-time stack, the compile-time stack is like its own run-time stack, but where all execution is at compile-time.
</span></p><p><span>The compile-time stack itself is &quot;dynamically typed&quot; in some sense, but the &quot;run-time&quot; for this stack is all at compile-time, so any errors here are still caught at compile-time. For example, there&#39;s no check that <code><span>tuple n</span></code> is always called when there are at least <code><span>n</span></code> types on the compile-time stack. Since <code><span>tuple n</span></code> is evaluated at compile-time, we can just wait for it to fail, and if it does then its a compile-time error. This is particularly significant since SaberVM has a reasonably powerful <i><span>kind</span></i> system too. Not like a kind-level lambda calculus (aka kind-polymorphism) or anything, but there are types, regions, capabilities, and representations, so there are a lot of ways to have a &quot;kind error,&quot; like by <code><span>req</span></code>-ing a representation instead of a type. Since the compile-time stack is just compile-time execution with these values, anything that could possibly go wrong here is caught at compile-time. And since there&#39;s no control flow for this compile-time language, everything takes linear time.
</span></p><p><span>To actually <i><span>use</span></i> this new compile-time stack, a few instructions manipulate <i><span>both</span></i> the compile-time stack and type stack. <code><span>req</span></code> pops a type off the compile-time stack and puts it at the end of the type stack (which really makes it a &quot;type VecDeque,&quot; to use the Rust term). This allows functions to specify &quot;arguments,&quot; that is, what they expect the top of the type stack to look like: each <code><span>req</span></code> in a function is recorded to know the full type of the function by the end, and ultimately typecheck function calls in other functions (or recursive ones). Other uses of the compile-time stack include what I mentioned earlier: polymorphic function calls pop their compile-time arguments from the compile-time stack (and perform the necessary substitutions in their type signature). One last notable example is <code><span>malloc</span></code>, which pops a type from the compile-time stack to know what its allocating and returning. There are many more uses of the compile-time stack in SaberVM&#39;s bytecode language; it&#39;s proven extremely useful, flexible, and ergonomic.
</span></p><h3><span>Benefits
</span></h3><p><span>This compile-time stack approach removes the upper bound on the power of the type specification language. With its own stack, there&#39;s no reason it couldn&#39;t be as powerful as the run-time language itself, a la dependent types. SaberVM doesn&#39;t use that power, in favor of faster typechecking and no need for user-provided proofs, but as a designer its nice to know how forward-compatible the typechecking system is with unpredictable extensions to the type system in the future. Hopefully no such extensions are needed, but SaberVM is still a young project, currently in the prototyping stage. This is very much a part of the design stage, so things can definitely change a lot.
</span></p><p><span>Another benefit is performance. SaberVM uses the fact that functions are in Continuation-Passing Style (that is, function calls are only the last instruction of functions, never earlier) for an extremely parallel algorithm: function types have no return type component to them, and all the compile-time instructions are before any <code><span>call</span></code> instructions. Therefore, SaberVM can get the type of each function without <i><span>any</span></i> knowledge of the types of other functions, by simply stopping when it gets to a call that calls a global function. Therefore, functions can be typechecked in parallel in any order. Once all the types are known, SaberVM goes through any calls to global (ie. not from a function parameter) functions and makes sure that those types are correct. This second pass is quick for each function call (functions aren&#39;t re-processed) and only happens for global function calls. Calling a parameter is very normal in Continuation-Passing Style code, so global function calls aren&#39;t as common as you&#39;d think anyway. The second pass is linear (big-O of N) in the number of global function calls, like how the first pass is linear in the size of the program, but both passes are trivial to parallelize; each iteration creates no information needed by future iterations. 
</span></p><p><span>Typechecking in a parallel way like this also makes the type errors trivially recoverable, see <a src="https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html"><span>this fantastic blog post</span></a> for more about that. 
</span></p><p><span>Lastly, the language is easy to compile to, for the same reasons stack-based bytecode always is. Type annotations are lowered in a recursive algorithm to make them in a sort of reverse-polish-notation form, and that Just Works™.
</span></p><h3><span>Conclusion
</span></h3><p><span>This was one of those ideas that I felt really proud of for some reason, even if it&#39;s basically just like Zig&#39;s <code><span>comptime</span></code>-based polymorphism but for stack-based bytecode. I don&#39;t know of any language that&#39;s doing anything like this. Having worked with the system for a while now, I&#39;m really really pleased with it.
</span></p><p><span>The main reference I have for prior work is <a src="https://binji.github.io/posts/webassembly-type-checking/"><span>this</span></a> great article on Web Assembly&#39;s typechecker.
</span></p><p><span>If you&#39;re interested in this project and want to know more, I have another post about it <a src="https://ryanbrewer.dev/posts/announcing-svm.html"><span>here</span></a>. If you&#39;re excited about SaberVM&#39;s future, consider starring it on <a src="https://github.com/RyanBrewer317/SaberVM"><span>github</span></a> (which has a more in-depth description of the project), or even <a src="https://github.com/sponsors/RyanBrewer317"><span>sponsoring</span></a> me or supporting me on <a src="https://ko-fi.com/ryanbrewer"><span>ko-fi</span></a>!
</span></p></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>