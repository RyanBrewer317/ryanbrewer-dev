<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title> - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1></h1><div class="date">January 1, 2024</div><div><span>After my last [https://ryanbrewer.dev/posts/safe-mmm-with-coeffects.html](post),<br>a few people seemed interested in the papers I read, <br>so I thought I&#39;d write a (necessarily long) post mapping out my experience of<br>programming language papers, with tons of recommendations for programming language<br>developers to start exploring.<br>At the end I&#39;ll have a list of all the papers I mention throughout the post.<br>Note that this is just my own journey through the academia, and will be missing plenty of important work.<br>Hopefully what I have here will serve as good jumping off points for your own PL research.<br></span></div><div><span>If you aren&#39;t familiar reading academic papers, don&#39;t worry!<br>It&#39;s not as hard as you think. <br>My best advice for getting started is patience.<br>Papers will often use terms you (or I) are not familiar with,<br>but then they&#39;ll define the terms later in the paper.<br>I don&#39;t know why people write this way, but it seems to be a convention.<br>Also, when you read a paper, start with the abstract, introduction, and conclusion.<br>Leave the actual technical details of the work to the end.<br></span></div><div><span>For terms that they don&#39;t define, there are two youtube playlists I HAVE to recommend, by<br>[https://youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_&amp;si=FIZVKTC8TXFz-IfI](Bartozs Milewski)<br>and [https://youtube.com/playlist?list=PLCTMeyjMKRkqTM2-9HXH81tvpdROs-nz3&amp;si=2iJc5syQCdk2rbjz](Richard Southwell).<br>I especially recommend the latter one, <br>for getting me up to speed on a ton of important concepts in an accessible way.<br>The things that it taught me that you should probably know:<br>intuitionistic logic, sequent calculus, dependent types, the Curry-Howard isomorphism.<br>If you don&#39;t like youtube videos, many blog posts across the internet explain pieces of these ideas.<br>Exercise your Google-Fu! (Or whatever search engine you use.)<br>Self learning requires a lot of googling.<br></span></div><div><span>The prerequisites for this post are all over the place:<br>if you don&#39;t understand something, just skip it!<br>There may be other things in other sections that are more digestable.<br>I hope this post will have something for people who are fairly advanced too, <br>since some of these things are pretty niche, even in PL.<br></span></div><h3><span>Static and Dynamic Analysis<br></span></h3><div><span>When your code doesn&#39;t compile because of a type error, it means the language is doing something called *static analysis.* <br>&quot;Static&quot; is an adjective referring to everything at compile-time.<br>&quot;Dynamic&quot; is the opposite, referring to everything at runtime.<br>Thus, &quot;dynamic analysis&quot; means doing some runtime checks, like guaranteeing that indexing into an array is in bounds<br>by crashing (or producing `undefined`) if it&#39;s not.<br></span></div><div><span>Type theory is the bread and butter of static analysis.<br>If you say `int x = 5;` then you&#39;re doing type theory, because `x` is given the *type* `int`.<br>If you then try to assign `x` the value `&quot;hello!&quot;` then that&#39;s a type error,<br>because any value of `x` must have the type `int`, but `&quot;hello!&quot;` has the type `string`.<br>Types are very familiar to programmers.<br></span></div><div><span>In a &quot;statically typed&quot; language, types are checked at compile-time.<br>In a &quot;dynamically typed&quot; language, types are checked at runtime.<br>In a &quot;strongly typed&quot; language, incompatible types leads to a crash or compile error.<br>In a &quot;weakly typed&quot; language, incompatible types are *coerced,* <br>meaning one of the incompatible values is modified to make the types match.<br>JavaScript is the classic example of a weakly typed language: `parseInt` needs its argument to be a string, <br>so if you give it something else then that thing will be implicitly turned into a string before `parseInt` starts working with it.<br></span></div><div><span>Dynamic typing is still absolutely a part of type theory, and I&#39;ve found some of the papers on it to be fascinating.<br>When you combine static and dynamic typing, you get a system that can express anything correct and rule out some incorrect things, <br>whereas type systems usually try to rule out all incorrect things and still allow some correct things. <br>They&#39;re inverse approaches.<br>[https://dl.acm.org/doi/10.1145/96709.96747](Quasi-static typing) (Satish Thatte) is my personal favorite paper on this, <br>related to a much more famous [https://dl.acm.org/doi/10.1145/75277.75296](paper) <br>with a godsquad of four researchers you should pay attention to.<br>Other interesting work on combining static and dynamic types (often called &quot;gradual typing&quot;) <br>are [https://homepages.inf.ed.ac.uk/wadler/topics/blame.html](blame) (Wadler) and <br>[https://users.soe.ucsc.edu/~cormac/papers/popl06-hybrid.pdf](hybrid typing) (Flanagan), <br>both from researchers that are worth keeping an eye on. <br>Wadler did much of the theoretical work behind Haskell, and Flanagan did much of the work behind ANF compilation.<br>I&#39;m sure I&#39;m forgetting important work here but that should be enough to give a good jumping off point for your own research.<br></span></div><h3><span>Dependent Types<br></span></h3><div><span>That&#39;s all I&#39;m going to say about dynamic types now, <br>since type theory generally tries to remove runtime checks as much as possible.<br>The farthest you can go with this is something called *dependent types.*<br>Dependent type theory is enormous but some names to know are Per Martin-Löf<br>(a logician and philosopher who came up with many of the original ideas)<br>and Thierry Coquand.<br></span></div><div><span>Dependent type theory can be quite difficult to grasp the first ten times you try,<br>but eventually the ideas will start to click, no matter your background.<br>Earlier I mentioned Richard Southwell&#39;s wonderful <br>[https://youtube.com/playlist?list=PLCTMeyjMKRkqTM2-9HXH81tvpdROs-nz3&amp;si=2iJc5syQCdk2rbjz](videos)<br>for learning dependent type theory, and I&#39;ve also written a [https://ryanbrewer.dev/posts/logic-in-types.html](post)<br>that tries to gently introduce the ideas.<br></span></div><div><span>The main thing you need to know about dependent types for now is that they allow you to express any<br>facts you want about your programs (more or less) and offer you a way to prove those facts.<br>So you could write a function that gets things from an array, but the given array has to be<br>big enough for the given index to make sense.<br>Then to use this function, you just write a proof that the array is big enough for the index.<br>It&#39;s quite a bit of effort compared to using types in traditional languages, <br>but it&#39;s very useful when program correctness really matters.<br>If you want the language to *figure out the proofs for you,*<br>check out [https://en.wikipedia.org/wiki/Liquid_Haskell](Liquid Haskell)&#39;s [https://arxiv.org/abs/2010.07763](refinement types).<br>Note that in general dependently typed languages use intuitionistic logic for their proofs;<br>if you&#39;re interested in expressing classical logic, check out the continuation stuff I mention later in the post.<br>Lean notably allows classical logic with its dependent types.<br></span></div><div><span>The classic dependently typed system is called the Calculus of Constructions, or CoC.<br>There&#39;s no way to express your typical functional-language ADTs in it,<br>so it&#39;s often extended to the Calculus of Inductive Constructions, or CIC,<br>which is really just CoC + (G)ADTs.<br>Cedille (which I discuss further later in the post) has another approach to adding ADTs<br>using pure lambda calculus, the details of which I won&#39;t discuss in this post.<br></span></div><div><span>Since we can do arbitrary computation in the type system in a dependently typed language,<br>we suddenly need types *for our types,* which we call *kinds.*<br>A very simple and beautiful formalization of this structure is<br>[https://www.cambridge.org/core/journals/journal-of-functional-programming/article/introduction-to-generalized-type-systems/869991BA6A99180BF96A616894C6D710](pure type systems)<br>or &quot;PTS&quot;s, by a very famous researcher named Henk Barendregt.<br>The paper I just linked calls them &quot;generalized type systems&quot; but that&#39;s not what anyone calls them anymore.<br>His &quot;\(\lambda\)-cube&quot; in that paper is extremely famous, with CoC being the most powerful system present. <br>So there aren&#39;t ADTs in any corner of the cube.<br>(And every corner of it is a system that definitely halts, so none of it is even turing complete!)<br></span></div><div><span>If you want you can have computation on the kind level, the heirarchy of types-of-types-of-types-of...<br>can go on forever (in which case they&#39;re called &quot;universes&quot;)<br>and the &quot;Extended CIC&quot; has such an infinite heirarchy.<br>The Coq (maybe renamed to Rocq?) dependently typed language is based on the extended CIC.<br></span></div><h3><span>Termination Checking<br></span></h3><div><span>Dependent types allow you to write functions that produce types,<br>and call those functions at compile-time to decide the types of your values.<br>That means you can have arbitrary code running at compile time,<br>so most dependently typed languages aren&#39;t allowed to loop forever.<br>(There are other reasons infinite loops are bad, which have to do with how dependent types express propositions and proofs.)<br>This segues to a super fascinating field about *termination checking.*<br>Think of it as &quot;how to get around the halting problem&quot; or<br>&quot;how bad is it, *really,* to be turing incomplete?&quot;<br>The goal is to be able to express normal programs while also knowing that none of those programs loop forever.<br></span></div><div><span>A very important part of termination checking is *rewrite theory.*<br>It&#39;s a very fun theory about computation where you have a list of symbols <br>(a &quot;term&quot;) and a set of rules (a &quot;term-rewriting system&quot; or TRS) <br>and you apply those rules in any order to the term until none of them apply anymore.<br>A rule might look like \(t\&amp;f\rightarrow f\), which shows a computation rule for logic.<br></span></div><div><span>Term rewriting represents computation as a bunch of terms with a &quot;rewrite-to&quot; relation between them;<br>that is, computation is done in set theory, and function composition is just relation transitivity.<br>It&#39;s quite elegant, and gives a nice language for talking about computation.<br>In particular, if there are no infinite sequence of steps in your rewrite relation,<br>then the rewrite system halts on every term you give it.<br>Often you show that the sequences are finite by assigning each term a positive integer <br>in such a way as to guarantee that each step in the relation always reduces the positive integer.<br>Since every term&#39;s integer is positive, you know that those subtractions can&#39;t go on forever.<br></span></div><div><span>A fun paper combining functional programming and rewrite theory is<br>[https://www.researchgate.net/publication/29622149_Decidable_Type_Inference_for_the_Polymorphic_Rewriting_Calculus](Decidable Type Inference for the Polymorphic Rewriting Calculus).<br>A great book on rewrite theory and termination checking is<br>[https://www.amazon.com/Term-Rewriting-That-Franz-Baader/dp/0521779200](Term Rewriting and All That) by Franz Baader and Tobias Nipkow<br>(who&#39;s a top researcher in rewrite theory).<br></span></div><div><span>Most dependently typed languages assign each term its &quot;depth,&quot; which is meant like the depth of a binary tree.<br>For a linked list, its depth is its length. <br>This is a useful positive integer to assign because recursion (the only way to loop forever in a functional language)<br>usually is applied to the subcomponents of a term, that is, terms whose depth are 1 less.<br>To support this and other reasoning, they&#39;ll often encode positive integers themselves as something like linked lists,<br>and do math using the lengths/depths.<br>The typical paper for termination checking a dependently typed language is <br>[https://www.semanticscholar.org/paper/foetus-Termination-Checker-for-Simple-Functional-Abel/c216d842401569de47d2472b84d33f4f38bbe670](foetus).<br>Another concept to know that encodes the depth idea more explicitly is<br>[https://dl.acm.org/doi/10.1145/328691.328893](sized typing).<br></span></div><div><span>Another very important angle of termination checking is *recursion schemes.*<br>As far as I know this came about in the very famous paper on<br>[https://www.researchgate.net/publication/2592417_Functional_Programming_with_Bananas_Lenses_Envelopes_and_Barbed_Wire](bananas, lenses, envelopes, and barbed wire).<br>They divide recursion into two types, called *catamorphisms* and *anamorphisms,* which are dual in category theory (look up &quot;F-Algebras&quot;).<br>Catamorphic recursion is when the size or depth is going down, as I discussed earlier;<br>computation is trickling down a tree into smaller and smaller subtrees.<br>Catamorphisms are guaranteed to halt.<br>Anamorphic recursion is when the size is going up, because you&#39;re building a tree and recursing on it.<br>For example, you might recursively push something onto a linked list until its length is 10 or more.<br>Anamorphisms (or corecursion) might not halt, in general,<br>so much of the recent research into termination checking focuses on them, <br>with terms like &quot;coinduction&quot; (anamorphism) and &quot;corecursion&quot; (apomorphism).<br>There are many other recursion schemes (hylo-, apo-, para-, etc.-morphisms, the list goes on).<br></span></div><div><span>One important recursion scheme is called &quot;Mendler-style&quot; recursion.<br>It&#39;s a fancy way of doing catamorphisms that the Cedille dependently typed language uses for all of its termination checking.<br>Cedille is interesting for many reasons, which I&#39;ll get into in the next section.<br></span></div><h3><span>Intrinsic and Extrinsic Typing<br></span></h3><div><span>In general when we think of types and type theory, we&#39;re thinking in terms of only *intrinsic* type theory,<br>or &quot;Church-style&quot; type theory, or &quot;type theory a la Church.&quot; (I swear it&#39;s called that.)<br>This means that the meaning of an expression is dependent on its type.<br>`fn foo(i: int) { return i; }` does nothing but return what you give it, <br>but we might say that if it was for `float` instead of `int` then it would be a different function.<br>*Extrinsic* typing argues that the `int` version and the `float` version are *the exact some function,*<br>namely its *untyped* behavior, and we just have various methods for *assigning* types to untyped expressions.<br>Much of the end result is the same, it&#39;s just a different way of looking at things.<br>Extrinsic type theory is also called &quot;Curry-style&quot; type theory or &quot;type theory a la Curry.&quot;<br></span></div><div><span>The most famous consequence of this way of thinking is *intersection types.*<br>These mean assigning one expression *multiple* types (so it&#39;s in the &quot;intersection&quot; of these types).<br>The most famous language that does this is TypeScript, by far.<br></span></div><div><span>Some intersection type systems can well-type all the expressions that halt,<br>and none of the expressions that don&#39;t, thereby characterizing halting in the type system.<br>Obviously, the typechecking for these systems is undecidable.<br></span></div><div><span>Within academia another very famous extrinsic system is Cedille.<br>Cedille is a dependently typed language with *dependent* intersection types,<br>meaning the second type in the intersection can refer to the value with that has the first type<br>(which is the second type&#39;s own value too, meaning the terms type can talk about the term itself).<br>It also has an [https://ryanbrewer.dev/posts/implicit-products-better-forall.html](implicit products)<br>which are like an infinitary intersection type.<br>(Here&#39;s a [https://link.springer.com/chapter/10.1007/978-3-540-78499-9_26](paper).)<br>Cedille also has an extrinsic equality type to let you really say that a no-op function for integers is equal to a no-op function for floats.<br>It does all of this to be able to express inductive types (ADTs) with a much smaller extension to the CoC than the CIC requires.<br>One of the Cedille papers is [https://github.com/cedille/cedille.github.io/blob/master/semantics.pdf](this) but many of them are very interesting.<br>If you like podcasts, Type Theory Forall has a couple wonderful episodes on Cedille.<br></span></div><div><span>Extrinsic type theory is very deep and has their own versions of many intrinsic things, like the \(\lambda\)-cube.<br>My favorite is the &quot;\(\Delta\)-chair&quot;, discussed [https://arxiv.org/abs/1803.09660](here).<br></span></div><h3><span>Performance<br></span></h3><div><span>Much of my favorite work on making functional languages fast is connected to Greg Morrisett, a researcher I really admire. <br>Work that he was a part of is a big inspiration for [https://ryanbrewer.dev/posts/announcing-svm.html](SaberVM), <br>as well as the Rust programming language.<br>I recommend the [https://dl.acm.org/doi/10.1145/1029873.1029883](papers on Cyclone),<br>Morrisett&#39;s [https://www.semanticscholar.org/paper/Compiling-with-Types-Morrisett/75c668959ae112943b32d75bccc2d8bd5d6ee3b6](PhD thesis),<br>[https://dl.acm.org/doi/10.1145/199448.199475](intensional polymorphism) (Robert Harper is a researcher to be aware of;<br>also I think [https://github.com/ollef/sixten](Sixten) uses something like this for its polymorphism),<br>and the [https://dl.acm.org/doi/10.1145/292540.292564](calculus of capabilities) <br>(which I have a [https://ryanbrewer.dev/posts/safe-mmm-with-coeffects.html](post) on).<br></span></div><div><span>A few of those suggestions use *regions,* a notion typically connected to<br>Tofte and Talpin&#39;s [https://www.sciencedirect.com/science/article/pii/S0890540196926139](region calculus).<br>It&#39;s a super famous paper about basically using arenas for functional programming, with lifetime inference.<br></span></div><div><span>The [https://arxiv.org/abs/2107.00522](Gibbon) compiler takes a subset of Haskell and improves cache locality and parallelism<br>by turning the datastructures into arrays. (Without the language user having to change anything in their code!)<br></span></div><div><span>Continuations are very very useful for compiling functional programs, as they let the functions kind of disappear.<br>The idea of a continuation is that instead of a function returning, <br>it takes a function as its argument and calls that function with what it would have returned.<br>Thus the caller says &quot;when you&#39;re done with your work, don&#39;t give it to me. Instead, send it over to this other function.&quot;<br>It&#39;s a transformation of the program into something that can just be expressed with jumps in machine code.<br>[https://ryanbrewer.dev/posts/announcing-svm.html](SaberVM) uses &quot;Continuation-Passing Style&quot; (CPS) <br>because it&#39;s such a useful structure for functional language compilers.<br>[https://www.cambridge.org/core/books/compiling-with-continuations/7CA9C36DCE78AD82218E745F43A4E740](Compiling With Continuations)<br>is the go-to reference on this, and I found it pretty accessible and helpful when I read it.<br>CPS is also really good for optimizations.<br>Since then [https://dl.acm.org/doi/10.1145/173262.155113](ANF) has become a popular alternative, for being simpler in certain ways<br>while still allowing many of the CPS optimizations.<br>The ANF researchers are yet more names you&#39;ll see more often.<br></span></div><div><span>There&#39;s a lot of interesting work on parallelism in functional languages.<br>[https://dl.acm.org/doi/10.1145/3371086](Par Means Parallel) is a paper using linear logic<br>(everything used exactly once) for parallelism.<br>[https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming](Choreographic programming)<br>is a really neat way of architecting distributed computation.<br>[https://dl.acm.org/doi/10.1145/2502323.2502326](LVars) use monotonicity to guarantee deadlock freedom.<br></span></div><div><span>Linear logic leads to good resource usage too.<br>[https://www.semanticscholar.org/paper/Linear-Types-can-Change-the-World!-Wadler/24c850390fba27fc6f3241cb34ce7bc6f3765627](Linear Types Can Change The World) <br>is a super famous paper using linear types for safe in-place updates of immutable values.<br>[https://link.springer.com/chapter/10.1007/11693024_2](this paper) also uses linear types, for much more of the memory management.<br>[https://link.springer.com/chapter/10.1007/3-540-46425-5_24](Alias Types) use linear logic but<br>separate the references from the &quot;proof things&quot; so that the references can still be used nonlinearly.<br></span></div><h3><span>Information Flow<br></span></h3><div><span>The last section I&#39;ll touch on is Information Flow Control, or IFC.<br>This is a big part of &quot;language-based security,&quot; where information security is achieved through programming language features.<br>[https://dl.acm.org/doi/10.1145/292540.292555](DCC) is the classic reference, <br>which is able to track and restrict the flow of information through programs.<br>[https://arxiv.org/abs/2104.10379](FLAC) extends this with trust relations that can change during the runtime of the program,<br>and some very elegant security and lattice theory.<br>DCC and FLAC use monads, and [https://arxiv.org/abs/2209.06334](this paper) brings in comonads as well for more interesting features,<br>in particular related to modal logic.<br>[https://dl.acm.org/doi/10.1145/3264820.3264823](This paper) offers a potential simplification of DCC.<br></span></div><div><span>Amal Ahmed and William Bowman have done a lot of work on something called &quot;secure compilation&quot;<br>or &quot;full abstraction,&quot; where the compiler produces something that is itself typed and preserves all the security guarantees of the source language.<br>Because of the expressivity of System F (the polymorphic typed lambda calculus),<br>it&#39;s seen as a useful target for compilation, as it can express many of the features of source languages.<br>For example, Haskell extends System F only a little bit, and has syntax sugar the compiles to it for everything else.<br>A really interesting paper relating this to information flow is [https://dl.acm.org/doi/10.1145/2784731.2784733](Noninterference For Free).<br>Noninterference is the property that IFC systems try to have (think of it as &quot;secrets don&#39;t get leaked&quot;)<br>and &quot;theorems for free&quot; is how we refer to the power of polymorphism in System F, referencing<br>[https://dl.acm.org/doi/10.1145/99370.99404](this classic paper).<br></span></div><h3><span>Conclusion (and the List of Papers)<br></span></h3><div><span>One final piece of advice I have for self-learning is talking to people.<br>Part of that means joining discord servers and subreddits and whatnot that<br>focus on programming languages, but another important part is talking to researchers.<br>When you find a paper with ideas that you really like,<br>collect a list of questions you have about it and send an email to the authors.<br>Cold emailing has been very successful for me,<br>and many wonderful papers I discovered were sent to me as responses from researchers I cold-emailed.<br>I discovered [https://arxiv.org/abs/1803.09660](intersection types) from emailing the authors of a <br>[https://www.researchgate.net/publication/29622149_Decidable_Type_Inference_for_the_Polymorphic_Rewriting_Calculus](paper using rewrite theory).<br>I discovered an [https://dl.acm.org/doi/10.1145/3607852](dependent type paper about Haskell) from emailing one of the guys behind <br>[https://cedille.github.io/](Cedille).<br>You have no idea what papers people will recommend to you,<br>but you can rest assured that the PL research community is generally quite friendly, patient, and thoughtful.<br></span></div><div><span>Finally, here&#39;s the promised list of papers:<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/96709.96747](Quasi-static typing)<br>(1990) by Satish R. Thatte.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/75277.75296](Dynamic typing in a statically-typed language)<br>(1989) by Martin Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin.<br></span></div><div>[<span>https://www.researchgate.net/publication/221602824_Well-Typed_Programs_Can&#39;t_Be_Blamed](Well-Typed Programs Can’t Be Blamed)<br>(2009) by Philip Wadler and Robert Bruce Findler.<br></span></div><div>[<span>https://users.soe.ucsc.edu/~cormac/papers/popl06-hybrid.pdf](Hybrid Type Checking)<br>(2006) by Cormac Flanagan.<br></span></div><div>[<span>https://arxiv.org/abs/2010.07763](Refinement Types: A Tutorial)<br>(2020) by Ranjit Jhala and Niki Vazou.<br></span></div><div>[<span>https://www.cambridge.org/core/journals/journal-of-functional-programming/article/introduction-to-generalized-type-systems/869991BA6A99180BF96A616894C6D710](Introduction to Generalized Type Systems)<br>(1991) by Henk Barendregt.<br></span></div><div>[<span>https://www.researchgate.net/publication/29622149_Decidable_Type_Inference_for_the_Polymorphic_Rewriting_Calculus](Decidable Type Inference for the Polymorphic Rewriting Calculus)<br>(2006) by Horatiu Cirstea, Claude Kirchner, Luigi Liquori, and Benjamin Wack.<br></span></div><div>[<span>https://www.amazon.com/Term-Rewriting-That-Franz-Baader/dp/0521779200](Term Rewriting and All That)<br>(1998) by Franz Baader and Tobias Nipkow.<br></span></div><div>[<span>https://www.semanticscholar.org/paper/foetus-Termination-Checker-for-Simple-Functional-Abel/c216d842401569de47d2472b84d33f4f38bbe670](foetus – Termination Checker for Simple Functional Programs)<br>(2002) by Andreas Abel.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/328691.328893](Calculating sized types)<br>(1999) by Wei-Ngan Chin and Siau-Cheng Khoo.<br></span></div><div>[<span>https://link.springer.com/chapter/10.1007/978-3-540-78499-9_26](The Implicit Calculus of Constructions as a Programming Language with Dependent Types)<br>(2008) by Bruno Barras and Bruno Bernardo.<br></span></div><div>[<span>https://github.com/cedille/cedille.github.io/blob/master/semantics.pdf](Syntax and Semantics of Cedille)<br>(2018) by Aaron Stump.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/1029873.1029883](Experience With Safe Manual Memory-Management in Cyclone)<br>(2004) by Michael Hicks, Greg Morrisett, Dan Grossman, and Trevor Jim.<br></span></div><div>[<span>https://www.semanticscholar.org/paper/Compiling-with-Types-Morrisett/75c668959ae112943b32d75bccc2d8bd5d6ee3b6](Compiling With Types)<br>(1995) by Greg Morrisett.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/199448.199475](Compiling Polymorphism Using Intensional Type Analysis)<br>(1995) by Robert Harper and Greg Morrisett.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/292540.292564](Typed Memory Management in a Calculus of Capabilities)<br>(1999) by Karl Crary, David Walker, and Greg Morrisett.<br></span></div><div>[<span>https://www.sciencedirect.com/science/article/pii/S0890540196926139](Region-Based Memory Management)<br>(1997) by Mads Tofte and Jean-Pierre Talpin.<br></span></div><div>[<span>https://arxiv.org/abs/2107.00522](Efficient Tree-Traversals: Reconciling Parallelism and Dense Data Representations)<br>(2021) by Chaitanya Koparkar, Mike Rainey, Michael Vollmer, Milind Kulkarni, and Ryan R. Newton.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/173262.155113](The Essence of Compiling with Continuations)<br>(1993) by Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/3371086](Par means parallel: multiplicative linear logic proofs as concurrent functional programs)<br>(2019) by Federico Aschieri and Francesco A. Genco.<br></span></div><div>[<span>https://portal.findresearcher.sdu.dk/en/publications/choreographic-programming](Choreographic Programming)<br>(2013) by Fabrizio Montesi.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/2502323.2502326](LVars: Lattice-based Data Structures for Deterministic Parallelism)<br>(2013) by Lindsey Kuper and Ryan R. Newton.<br></span></div><div>[<span>https://www.semanticscholar.org/paper/Linear-Types-can-Change-the-World!-Wadler/24c850390fba27fc6f3241cb34ce7bc6f3765627](Linear Types can Change The World!)<br>(1990) by Philip Wadler.<br></span></div><div>[<span>https://link.springer.com/chapter/10.1007/11693024_2](Linear Regions Are All You Need)<br>(2006) by Matthew Fluet, Greg Morrisett, and Amal Ahmed.<br></span></div><div>[<span>https://link.springer.com/chapter/10.1007/3-540-46425-5_24](Alias Types)<br>(2000) by Frederick Smith, David Walker, and Greg Morrisett.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/292540.292555](A Core Calculus of Dependency)<br>(1999) by Martín Abadi, Anindya Banerjee, Nevin Heintze, and Jon G. Riecke.<br></span></div><div>[<span>https://arxiv.org/abs/2104.10379](A Calculus for Flow-Limited Authorization)<br>(2021) by Owen Arden, Anitha Gollamudi, Ethan Cecchetti, Stephen Chong, and Andrew C. Myers.<br></span></div><div>[<span>https://arxiv.org/abs/2209.06334](Monadic and Comonadic Aspects of Dependency Analysis)<br>(2022) by Pritam Choudhury.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/3264820.3264823](A Perspective on the Dependency Core Calculus)<br>(2018) by Maximilian Algehed.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/2784731.2784733](Noninterference For Free)<br>(2015) by William Bowman and Amal Ahmed.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/99370.99404](Theorems for free!)<br>(1989) by Philip Wadler.<br></span></div><div>[<span>https://arxiv.org/abs/1803.09660](The Delta-calculus: syntax and types)<br>(2018) by Luigi Liquori and Claude Stolze.<br></span></div><div>[<span>https://dl.acm.org/doi/10.1145/3607852](Dependently-Typed Programming with Logical Equality Reflection)<br>(2023) by Yiyan Liu and Stephanie Weirich.<br></span></div></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>