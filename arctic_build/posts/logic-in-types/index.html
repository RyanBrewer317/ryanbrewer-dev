<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title> - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">â˜°</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1></h1><div class="date">December 1, 2023</div><div><span>When I was first introduced to proof assistants like Coq, I thought it would be graduate-level material<br>that was way beyond what I could ever hope to understand. However, the essence of how they work is surprisingly simple,<br>and very beautiful. In this post I will explain the intuition behind dependent types and their relationship with proofs,<br>using a C-like syntax.<br></span></div><div><span>A little familiarity with dependent types and proof assistants like Agda or Coq <br>will help you understand this post, but isn&#39;t necessary.<br>A familiarity with basic logic is assumed, including &quot;for all.&quot;<br>A familiarity with programming in statically-typed languages like C, Go, OCaml, or TypeScript is assumed.<br></span></div><h3><span>Logic in Types<br></span></h3><div><span>In academia, there is a well-known correspondence between logic and type systems,<br>called the Curry-Howard Isomorphism. <br>It&#39;s a big name but the idea is simple:<br>if a type has a value in it,<br>then it&#39;s &quot;true,&quot; and if it&#39;s empty, it&#39;s &quot;false.&quot; <br>So `void` is false and `int` is true, for example.<br></span></div><div><span>Structs (pairs, tuples, records, etc.) only have values if all the component types have values:<br>you could never make a struct of type `struct{void a, int b}` <br>because you would need a value of type `void` to construct it.<br>This gets us a way to express logical &quot;and:&quot; `struct{void a, int b}` is &quot;false,&quot; `struct{int a, int b}` is &quot;true.&quot;<br></span></div><div><span>Enums (tagged unions, etc.) have values if any of the component types have values.<br>For example, `enum{void a, int b}` has values, namely integers tagged with `b`.<br>`enum{void a, void b}`, on the other hand, is a type with no values, and is therefore &quot;false.&quot;<br>This gets us a way to express logical &quot;or.&quot;<br></span></div><div><span>Functions (pure, side-effect-free ones, that is) operate like implication.<br>if the input type has values, then any value in the function type can be used to construct a value of the output type.<br>This needs examples.<br>`void-&gt;void` is a type with a value, namely `(x: void)=&gt;x` in a TypeScript anonymous-function notation, <br>so it&#39;s &quot;true&quot; but not very useful.<br>`void-&gt;int` is a type with values, such as `(x: void)=&gt;7`, but also isn&#39;t useful.<br>You&#39;d need values of type `void` to be able to call these functions!<br>`int-&gt;int` is a familiar type which of course has many values, such as `const square = (x: int) =&gt; x * x`.<br></span></div><div>`<span>int-&gt;void` *doesn&#39;t* have values. Why? Say we had a function `f` of type `int-&gt;void`. <br>Then we could call `f(5)` and get a value of type `void` back, which is impossible.<br>So `int -&gt; void` is a type with no values, because any such values would be able to construct elements of `void`.<br>Hopefully these examples make it clear why functions work like implication.<br></span></div><div><span>Logical negation is simply represented by a function returning `void`, because<br>&quot;not p&quot; and &quot;p implies false&quot; are equivalent.<br>That&#39;s another explanation of why `int-&gt;void` is empty: it&#39;s kind of like &quot;not `int`,&quot; and we know `int` is &quot;true.&quot;<br>Note that this logic also doesn&#39;t have &quot;p or not p&quot; as an axiom. It is &quot;intuitionistic.&quot;<br></span></div><h3><span>The Point<br></span></h3><div><span>Is all of this useful? Yes, it&#39;s proven its worth. <br>Because the details of this correspondence is about types having values, you can make sure functions are<br>only called under the right conditions. <br>Simply add a parameter to the function in question; a parameter whose type corresponds to the desired precondition. <br>Then the function can&#39;t be called unless a value (called a &quot;proof&quot; in this context) of that type is given.<br>In other words, it can only be called if the type is &quot;true.&quot;<br>The classic example is something like, for a list of integers, `int get(int[] l, int i, 0&lt;=i&lt;length(l) p)`.<br>This function is called with three arguments: an `int[]`, an `int`, and a `0&lt;=i&lt;length(l)`.<br></span></div><div><span>The correspondence I described above doesn&#39;t tell you how to construct the type `0&lt;=i&lt;length(l).`<br>It&#39;s a very strange-looking type.<br>At the very least, it&#39;s a struct: the conjunction of two propositions \(0 le i\) and \(i &lt; length(l)\).<br>This is where dependent types come in.<br></span></div><h3><span>Dependent Types<br></span></h3><div><span>Dependent function types (&quot;Pi&quot; types) are function types where the type of the output can refer to values of the input types.<br>What does this mean? <br>We can have a function `f` which takes an argument `a: A` and the type of `f(a)` <br>*changes* based on the specific value of `a`.<br>If `f` is defined as `(t: type)=&gt;(x: t)=&gt;x` then `f(int)(7)` returns `7`, and `f(float)(1.4)` returns `1.4`.<br>That is, `f(T)` returns the identity function for type `T`.<br></span></div><div><span>The notation for a Pi type is \(Pi x: A. B\) which I will write in a TypeScript-y notation as `(x: A)-&gt;B`.<br>Note the `-&gt;` instead of `=&gt;` to show that this is a type, not a function. <br>However, `x` is in scope in `B` like a function.<br></span></div><div><span>Extending this to the setting of multiple-argument functions, it also means that input types can refer to the given values of earlier parameters.<br>The `get` function above has a dependent function type, because the type `0&lt;=i&lt;length(l)` refers to the earlier parameters `i` and `l`.<br>This type is really `struct{0&lt;=i a, i&lt;length(l) b}`, since it&#39;s a logical &quot;and.&quot;<br>The `&lt;=` and `&lt;` operators here are definable functions, which take integers as arguments and produce types. <br>I won&#39;t get into their definitions here but I may in a future post, and the interested reader can find them online.<br>So anyway, `get` can be called only if a struct can be constructed with two fields that respectively satisfy these two inequalities.<br>That&#39;s great!<br></span></div><div><span>Dependent function types have another use here, which is that they&#39;re the main way people represent logic&#39;s &quot;forall&quot; quantifier, \(orall\).<br>That is, if your proposition is \(orall n: int. n &lt; 5 implies n &lt; 6\) or something like that, <br>you generally use a dependent function type.<br>The type would be something like `(n: int)-&gt;(n &lt; 5)-&gt;(n &lt; 6)`. <br>The intuition I have for why this is the case goes as follows: <br>If you tell me about a machine that takes quarters and produces gumballs, I&#39;ll assume you&#39;re talking about real life.<br>*However,* if you then say that there&#39;s a 1% random chance that the machine produces instead teleports the user into the Harry Potter world,<br>then it will suddenly become clear to me that you were talking about an imaginary machine all along. <br>Even though the impossible thing happens only sometimes, and possibly never.<br></span></div><div><span>A more rigorous reason for why Pi types work like &quot;for all&quot; is because <br>functions of Pi types can only be constructed if *every possible result type* has a value.<br>In the case of `(n: int)-&gt;(n &lt; 5)-&gt;(n &lt; 6)`, a value of this type *can* be created, <br>because proving that n is less than 5 is sufficient to prove that it is less than 6.<br>If the type were instead `(n: int)-&gt;(n &gt; 5)-&gt;(n &gt; 6)`, and we have a function `f` of this type,<br>then it could be called like `f(6)(proof_5_le_6)` which are all valid terms, <br>and then as a result you&#39;d have a value of type `6 &gt; 6`, which is &quot;false&quot; and has no values.<br>Therefore this function `f` can&#39;t exist. <br>Calling it with other arguments, like `f(4)(proof_4_le_6)`, *would* hypothetically be valid, <br>except that the function as a whole can&#39;t possibly exist because it would be possible to use it to get values of an empty type. <br>This is why dependent function types let you express &quot;for all&quot; in your types.<br></span></div><h3><span>Tip of the Iceberg<br></span></h3><div><span>This concludes my first real blog post. <br>Needless to say these ideas are the tip of a very large iceberg.<br>For example, types like `int` seem pretty different from useful proposition types like `0&lt;=i`.<br>To find out more about that difference, look up `Prop` and `Set` in Coq&#39;s type system.<br>I also didn&#39;t explain &quot;there exists;&quot; <br>The search term here is &quot;Sigma&quot; (\(Sigma\)) types, which I may write about more in the future.<br>And there&#39;s still a ways to go before you get a full proof assistant.<br>I think that this article gives a good foundation for exploring this iceberg on your own,<br>but it was intended to set up future posts I want to write<br>about the corners of the iceberg that really fascinate me.<br></span></div></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">Â© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>