<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title> - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1></h1><div class="date">January 1, 2024</div><div><span>In this post I&#39;m excited to announce the [https://github.com/RyanBrewer317/SaberVM](Saber Virtual Machine), or SaberVM.<br>It&#39;s a project I&#39;ve been working hard on for the past month,<br>with fascinating properties and an in-progress MVP implementation that&#39;s<br>coming along well.<br>If you like writing functional languages and want a portable backend to target that&#39;s fast and/or safe,<br>you may be very interested in SaberVM, especially in its upcoming AOT-compile-to-optimized-native form.<br></span></div><h3><span>What is it?<br></span></h3><div><span>SaberVM is a compiler backend for functional languages.<br>Specifically, it is an abstract stack machine, with many possible implementations.<br>It takes in CPS code that&#39;s been closure-converted and hoisted,<br>and executes it or AOT compiles it to a native binary.<br>My current implementation is a naive bytecode VM in Rust, without JITing, <br>mostly for rapid prototyping as the design settles.<br></span></div><div><span>The goals of the project are safety, expressivity, portability, and reliability.<br>To give a very quick overview,<br>safety is achieved through a carefully designed type system, and primarily includes memory safety. <br>Expressivity is preserved by using runtime checks and tagging for some of the safety guarantees,<br>so you can use any convoluted memory scheme you want so long as you don&#39;t dereference a dangling pointer.<br>SaberVM offers portability by being designed to be simple to implement on a variety of platforms.<br>Lastly, SaberVM is reliable because of a built-in crash recovery system you can use to microreboot <br>without the whole program terminating, like Erlang&#39;s BEAM.<br></span></div><div><span>The two main systems of SaberVM are *regions* and *exceptions.*<br></span></div><h3><span>Regions<br></span></h3><div><span>A region can be thought of as an arena with a malloc/free-style internal memory management system. <br>To read or write from the heap, you need a region. It can be the heap itself. <br>Regions have statically-checked lifetimes, and a [https://dl.acm.org/doi/10.1145/292540.292564](capability)-based system <br>for checking that values within that region are only read or written to during the lifetime of the region. <br>When a region&#39;s lifetime ends, it is freed like an arena.<br></span></div><div><span>This structure of memory is important because in a safe compilation the values in the heap are tagged with information <br>about which inhabitant is at that place in memory, so pointers can check that they&#39;re <br>pointing at the thing they think they are when they&#39;re dereferenced. <br>This introduces a memory fragmentation issue: <br>&quot;slots&quot; in memory can then later be used only by values that are the same size or smaller; they have an unchangeable &quot;max size.&quot; <br>To prove this, consider two values adjacent in memory, `A` and `B`, and their pointers, <br>`&amp;A` and `&amp;B`. Now say we free both, and allocate `C` at the same address where `A` was (that is, `&amp;C == &amp;A`). <br>If `C` is bigger than `A` was, then it has arbitrary control of the bytes used to tag `B`! <br>That means a nefarious program could potentially cause `&amp;B` to think that `B` is still there, leading dereferences to not crash but <br>instead to read memory controlled by `C` but think that it&#39;s `B`.<br></span></div><div><span>If allocating something in memory fixes a certain max-size for that chunk of memory for the rest of the program&#39;s lifetime, <br>that can cause issues from a poor use of memory. <br>Therefore, SaberVM puts its values in regions so there are certain points where it&#39;s statically known that nothing will <br>dereference some set of pointers ever again, so their referent memory can be really freed, with no restriction on its future use. <br>As a language writer, if you find your output programs have significant fragmentation issues, <br>you can do some light region inference to fix it. <br>In addition, since regions are freed like arenas, <br>regions offer a way to deallocate a bunch of memory instantly, and improve cache locality.<br></span></div><h3><span>Exceptions<br></span></h3><div><span>SaberVM&#39;s other interesting system is exceptions. Exceptions in SaberVM are not like normal exceptions, <br>though there&#39;s nothing stopping a compiler writer from building a normal exception system on top of SaberVM. <br>Instead, SaberVM exceptions don&#39;t take arguments. Every function must have a catch-all exception case, and only that. <br>Why? Having this built-in to SaberVM means that instructions that fail at runtime don&#39;t crash your program, <br>they just jump to the exception handler. <br>The language targeting SaberVM is then expected to produce exception handlers that do at least one of four things:<br>crash the program (with an explicit halt instruction),<br>rethrow the exception (that is, jump to the caller&#39;s catch-all exception handler),<br>restart the crashed function (in a microreboot or Erlang style, without information about what caused the exception), or<br>release held resources (currently SaberVM doesn&#39;t have locks, only CAS, but this is likely to change).<br></span></div><div><span>Note that SaberVM exceptions are *not* expected to be how your own language handles its exceptions!<br>For example, if you prefer a `Result`-style exception handling, <br>you can write functions that attempt single fallible instructions with an exception handler that produces <br>the corresponding `Err` value.<br></span></div><h3><span>Conclusion<br></span></h3><div><span>SaberVM is carefully designed but still a very young project. <br>I have an in-progress [https://github.com/RyanBrewer317/SaberVM](implementation) in Rust<br>that I call the MVP, a subset of the final SaberVM that isn&#39;t even necessarily forwards-compatible,<br>just to play with the ideas and their interactions and see how they really work in practice.<br>I&#39;m sure as I learn more the design will change somewhat but the core ideas and goals are very strong.<br></span></div><div><span>I&#39;ve gotten most of the typechecker done in just a few days, which is really promising,<br>and the algorithms are very simple. (I&#39;ll post more about them soon!)<br>I think the VM runtime will be easier to write than the typechecker, since it&#39;ll be a naive prototype<br>(without, say, JIT compiling), so I&#39;d say the implementation is about halfway done, which is very exciting.<br></span></div><div><span>If you&#39;ve read this far and think that the project sounds interesting, consider<br>starring it on [https://github.com/RyanBrewer317/SaberVM](github), or even<br>sponsoring my work on [https://github.com/sponsors/RyanBrewer317](github) or <br>[https://ko-fi.com/ryanbrewer](ko-fi)!<br></span></div></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>