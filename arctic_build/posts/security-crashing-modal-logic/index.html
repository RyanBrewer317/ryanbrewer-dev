<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title> - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">â˜°</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1></h1><div class="date">December 1, 2023</div><div><span>Modal logic is a fascinating field which has been applied to computer science in all sorts of weird ways.<br>In this post I&#39;ll talk about an interpretation of modal logic that I&#39;ve been exploring<br>which gives type-theoretic interpretations to crashing and security.<br></span></div><div><span>This post assumes a familiarity with logic,<br>and a very vague familiarity with monads, comonads, and the [/logic-in-types.html](Curry-Howard correspondance).<br>Also, I need to say from the start that this post is not very rigorous;<br>it&#39;s meant as interesting food for thought and intuition.<br></span></div><h3><span>What&#39;s Modal Logic?<br></span></h3><div><span>Modal logic is a version of logic that has two new and fascinating operators, `Possibly` and `Necessarily`. <br>These operators work exactly as you&#39;d expect, but it&#39;s hard to say exactly *what* it is that we expect,<br>so I&#39;ll simplify the idea. Consider the python program below:<br></span></div><pre><code># this is equivalent to print(input() + 4) 
# but the variables make it easier to talk about
x = input()
y = 2 + 2 # always evaluates to 4
z = y + x # depends on user input
print(z)
</code></pre><div><span>When a program is run, it has some set of inputs that change how the program progresses to completion.<br>In this case, it&#39;s the value assigned to `x`.<br>For a given run of the program, it only has one concrete input, and only unfolds in one way.<br>If you enter `3`, the program calculates and prints `7`.<br>But there are other ways it *could* have gone, if the original input were different.<br>It wouldn&#39;t have printed `7` if the input were, say, `5`.<br>And there are some parts of each run of the program that are the same no matter what the inputs are,<br>like the value of `y`.<br>Framed in modal logic, we&#39;ll say that `z` is *possibly* `7`, and `y` is *necessarily* `4`.<br>*That&#39;s* the understanding of possibility and necessity we&#39;ll use for this post.<br>A vocabulary for talking about different runs of a given program.<br>Regular propositions are for the &quot;current run,&quot; <br>necessary ones are true in all runs,<br>and possible ones are true in some runs, which could be the current one but might not be.<br></span></div><div><span>In logic, &quot;\(P\) is possible&quot; is written \(\Diamond P\)<br>and &quot;\(P\) is necessary&quot; is written \(\Box P\).<br></span></div><div><span>First of all, it&#39;s worth taking a moment to appreciate the beauty of modal logic.<br>Possibility and necessity are dual in the same way conjunction and disjunction are,<br>or universal and existential quantification are. <br>That is, take some proposition \(P\). <br>\(\neg (\Diamond (\neg P))\), or &quot;it is not possible that \(P\) is false,&quot;<br>is equivalent to \(\Box P\), or &quot;\(P\) is necessary.&quot;<br>\(\neg (\Box (\neg P))\), or &quot;it is not necessary that \(P\) is false,&quot;<br>is equivalent to \(\Diamond P\), or &quot;\(P\) is possible.&quot;<br>That is, negating the inputs and outputs of one gets you the other, <br>just like conjunction/disjunction and just like existential/universal quantification.<br></span></div><div><span>They&#39;re also dual in a sort of category-theory way:<br>possibility is a monad and necessity is a comonad.<br>Showing why is a nice demonstration of the modalities,<br>so here it is: for any proposition \(P\), <br></span></div><div><div class="math-block">\[P\implies\Diamond P\]</div><div class="math-block">\[\Diamond (\Diamond P)\implies\Diamond P\]</div><div class="math-block">\[\Box P\implies P\]</div><div class="math-block">\[\Box P\implies\Box (\Box P)\]</div><div class="math-block">\[\]</div></div><div><span>You can see in these rules the monadic &quot;return&quot; and &quot;join&quot; operations<br>and comonadic &quot;extract&quot; and &quot;duplicate&quot; operations.<br>It&#39;s also worth going through them and intuitively checking if they make sense.<br></span></div><h3><span>Security<br></span></h3><div><span>If you&#39;re familiar with language-based security theory,<br>you might immediately see a use for this.<br>LBS is largely built around a concept called [https://en.wikipedia.org/wiki/Non-interference_(security)](noninterference),<br>the property that secret inputs don&#39;t interfere with less-secret outputs.<br>It&#39;s a [https://en.wikipedia.org/wiki/Hyperproperty](hyperproperty),<br>meaning that it&#39;s talking about all possible runs of the program<br>instead of just a few particular ones.<br>Sound familiar?<br>In our modal vocabulary we might say that public outputs are<br>*necessary* with respect to secret inputs;<br>they aren&#39;t affected in any run of the program by those inputs.<br></span></div><div><span>This is a little bit different from how LBS is usually studied.<br>To oversimplify, there&#39;s usually a `Secret` monad that<br>ensures the values it holds can only affect other `Secret` values.<br>In the modal language, however, we&#39;re talking about a <br>`Public` comonad that makes sure the held value only depends on `Public` values. <br>This flipping of perspective has been studied a bit,<br>most notably by [https://dl.acm.org/doi/abs/10.1145/3563335](Choudhury).<br>He takes inspiration from a system by [https://dl.acm.org/doi/10.1145/3011069](Davies) (that is<br>explicitly inspired by necessity in modal logic) that is used to <br>determine which expressions in a language don&#39;t depend on user input,<br>and can therefore be evaluated at compiletime as an optimization.<br>This is like noticing that `y` is necessarily `4` in the python code above,<br>and removing the addition.<br>Choudhury extends this idea for language-based security, <br>combining it with the `Secret` monad I just mentioned.<br></span></div><h3><span>Crashing<br></span></h3><div><span>Consider for a moment what it is that an [https://www.w3schools.com/python/ref_keyword_assert.asp](assert statement) <br>does in a program. Hopefully it does nothing!<br>It has some proposition that it expects to be true in the current run of the program,<br>and it crashes if it doesn&#39;t.<br>We can describe this naturally in our modal vocabulary: it takes a proposition<br>that&#39;s *possibly* true (true in some runs of the program) and &quot;proves&quot; <br>that it&#39;s true in the current run by crashing if it&#39;s not: \(\Diamond P\implies P\).<br>This is a weird sort of implication because it&#39;s not generally true:<br>not all things that are *possibly* true are *actually* true.<br>It&#39;s like an &quot;extract&quot; operation for monads: it doesn&#39;t generally exist. <br>(Side note: Rust&#39;s `unwrap` operation for the `Result` monad comes to mind.)<br>Therefore it&#39;s an implication that you don&#39;t want to be applying unless you really think <br>it&#39;s true for the proposition in question.<br></span></div><div><span>We talked a lot about duality in this post so far,<br>so just for some informal fun, what would the dual of an assertion be?<br>If an assertion is an implication \(\Diamond P\implies P\) then its dual<br>would be an implication \(P\implies\Box P\), which *also* doesn&#39;t exist in general.<br>What does it mean? <br>If \(P\) is true in *this* run then it&#39;s true in *every other run.*<br>This is obviously not true in general but we can imagine that it works like assertions,<br>simply crashing the program when it&#39;s false.<br></span></div><div><span>This is a *weird* operation: take some fact about the current run of the program,<br>and crash the program if it&#39;s not true in every other run of the program.<br>Is there anything like this in computer science?<br>There actually *is,* surprisingly enough, and big corporations like Amazon are<br>using it to make a ton of money.<br>It&#39;s called [https://scholar.google.com/scholar?hl=en&amp;q=dynamic+taint+analysis](dynamic taint tracking).<br>The idea is you &quot;taint&quot; certain inputs at runtime which may give sensitive information,<br>then you taint every value that is derived from the inputs,<br>then if a tainted value is about to be printed in a public way, the program crashes.<br>This can easily be seen in terms of the `Public` comonad I mentioned earlier:<br>dynamic taint tracking takes a value and coerces it to be `Public`, and thus publicly viewable,<br>crashing if the value depends on sensitive information.<br>That is, the program crashes if the value isn&#39;t *necessary* with respect to the secret inputs.<br></span></div><h3><span>Conclusion<br></span></h3><div><span>That&#39;s all I have to say about this stuff for now but I hope to keep exploring<br>modal logic as a language for security and crashing.<br>I care a lot about crashing because I like the [https://en.wikipedia.org/wiki/Crash-only_software](crash-only software)<br>philosophy a lot, and [https://en.wikipedia.org/wiki/Microreboot](microreboot) architectures,<br>but I&#39;m a type theorist and logician primarily.<br>I have a crash-based project I&#39;m working on that I&#39;ll hopefully post about soon.<br>Also, if you&#39;re interested in how comonads are useful I&#39;ve *got* to link [https://dl.acm.org/doi/10.1145/3408993](this).<br>I hope this was interesting!<br></span></div></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">Â© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>