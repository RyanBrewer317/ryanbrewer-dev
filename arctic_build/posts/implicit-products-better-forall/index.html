<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title> - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1></h1><div class="date">December 1, 2023</div><div><span>In this post I&#39;ll talk about a type theory idea that deserves more attention: implicit products.<br>They came about in the 1998 dissertation of Alexandre Miquel, <br>but for English speakers a common citation would be <br>[https://www.semanticscholar.org/paper/The-Implicit-Calculus-of-Constructions-Extending-an-Miquel/990f8f44e011192122dfd35617f8cabf08052d60](The Implicit Calculus of Constructions).<br>They are used most notably in the [https://cedille.github.io/](Cedille) proof assistant.<br></span></div><div><span>This post assumes familiarity with logic (including the universal quantifer &quot;for all&quot;), <br>[/posts/logic-in-types.html](dependent types), very basic set theory, and the \(\lambda\)-calculus.<br></span></div><h3><span>What is it?<br></span></h3><div><span>For a moment, you&#39;ll have to ignore the strange name *implicit product.*<br>It makes a lot of sense once you know how they&#39;re used, but I&#39;ll get to that later.<br>Think of an implicit product like a universal quantifer (&quot;for all&quot;) in logic.<br>It&#39;s written like:<br></span></div><div><div class="math-block">\[\forall x: A. B(x)\]</div><div class="math-block">\[\]</div></div><div><span>where \(A\) is a type (proposition) and \(B\) is a type that may refer to \(x\) (predicate).<br>An implicit product is a type that is inhabited if \(B(x)\) is inhabited for every \(x\) in \(A\).<br></span></div><div><span>In the most recent iterations of the theory, you make a value of this type by writing \(\Lambda x: A. e\)<br>where, crucially, \(x\) can appear in the types in \(e\) but not in anything that could stick around &#39;til runtime.<br>That is, if you erase all the types of \(e\), the \(x\) isn&#39;t used in it at all.<br>To use such a term \(\Lambda x: A. e\) you call it like a \(\lambda\)-abstraction.<br>For the purpose of type-inference you might mark the call with some additional symbol to make it clear<br>that the function is a \(\Lambda\)-abstraction and not a \(\lambda\)-abstraction.<br></span></div><h3><span>Infinite Intersection<br></span></h3><div><span>On the surface this might just seem like a worse \(\Pi\)-type, which is the usual &quot;for all&quot; in something<br>like Coq, Agda, or Lean. <br>The only real difference, from what I&#39;ve said so far, is that the parameter of the abstraction isn&#39;t used at runtime. <br>But this makes all the difference. <br></span></div><div><span>A \(\Pi\)-type represents &quot;for all&quot; in a strange, roundabout way: it&#39;s a function (implication) from *data* (not a proposition)<br>to a proposition about that data, and can only be constructed if every proposition it returns can be constructed given the data of that<br>proposition.<br></span></div><div><span>When you learn about &quot;for all&quot; and &quot;there exists&quot; in logic, that isn&#39;t at all how you normally learn it.<br>Instead, &quot;for all&quot; is seen as a possibly-infinite conjunction for every element of a possibly-infinite domain.<br>&quot;There exists&quot; is, dually, a possibly-infinite *disjunction* for every element of a possibly-infinite domain.<br>\(\Sigma\)-types can kind of be seen that way for existential quantification, but \(\Pi\)-types definitely can&#39;t,<br>because again, they&#39;re a bit like an implication from a non-proposition.<br>They work for doing logic, of course; they&#39;re just a little weird.<br></span></div><div><span>Implicit products fix this. <br>An implicit product is a possibly-infinite *intersection* (conjunction) of all the possible &quot;return types.&quot;<br>\(\forall x: A. B(x)\) is an intersection of all types \(B(x)\) for each \(x\) in \(A\).<br></span></div><div><span>What&#39;s an intersection type? <br>They&#39;re what you get when you say that a term (say, \(e\)) could have one type (say, \(A\)) or another type (say, \(B\)).<br>Then you might say \(e: A\cap B\), that is, \(e\) is in the *intersection* between the types \(A\) and \(B\).<br>This isn&#39;t the standard way of doing conjunction in logic (pairs/structs/records/tuples are), <br>but it should be clear that if \(A\cap B\) has a value in it (and is therefore &quot;true&quot;), <br>then \(A\) and \(B\) also have values in them (are &quot;true&quot;), namely that same value in their intersection.<br>So it acts like a conjunction here.<br></span></div><div><span>But wait, if it&#39;s just an intersection of all the return types, it&#39;s not really a function, right?<br>How is that possible? We literally have calls to \(\Lambda\)-abstractions!<br>The secret is, since they don&#39;t use their parameter for evaluation, it&#39;s perfectly fine to evaluate them with no argument at all!<br>(In the absense of side-effects, of course.)<br>At runtime, \((\Lambda x: A. \lambda y: B. e)(a)(b)\) evaluates as \((\lambda y. e)(b)\). <br>Therefore, values of type \(\forall x: A. B(x)\) execute as some kind of \(B\), <br>and we know that its argument (\(x\)) doesn&#39;t matter.<br></span></div><div><span>Implicit products are generalization in their truest form: some aspect of a value could work for multiple types,<br>so the type gets replaced with a type variable, and the whole type becomes an intersection of all the possible<br>instantiations of that type variable. <br>This is why I argue that implicit products make for a &quot;better&quot; interpretation of the universal quantifier than \(\Pi\)-types.<br></span></div><h3><span>What&#39;s with that name though?<br></span></h3><div><span>The other reason implicit products are interesting is from a compiler engineering perspective.<br>When developing a dependently typed language, a huge optimization to make is erasing the proofs at runtime,<br>much like one erases the types at runtime. <br>The only thing that should remain are values of actual *data*types, like `int`, <br>as opposed to proofs of propositions (which are technically still values of types).<br></span></div><div><span>To that end, languages like Idris and Agda, and the extraction of OCaml code from Coq code, <br>have put a lot of effort into *proof irrelevance,* the property that proofs don&#39;t affect runtime execution.<br>Idris has Quantitative Type Theory for this, which allows it to say that the variables bound by some <br>\(\lambda\)-abstractions aren&#39;t used &quot;relevantly&quot; in the body of the abstraction. <br>That is, it can be used in things that get erased, but nothing that makes it to runtime.<br>Sound familiar? These &quot;0-quantity&quot; \(\lambda\)-abstractions are very similar to implicit products.<br>The only real difference is that they&#39;re philosophically still functions, not giant intersections.<br>The erasure of the argument is an optimization, nothing more. <br>Regardless, this similarity shows how using implicit products in your language automatically gives you a big optimization.<br></span></div><div><span>The &quot;0-quantity&quot; \(\lambda\)-abstractions of Idris&#39; QTT are called &quot;implicit.&quot;<br>This is a common term for arguments that we expect to disappear at runtime.<br>There is the risk of confusion with another meaning for &quot;implicit&quot; in this context:<br>arguments which you *don&#39;t* write but which (possibly) *are* present at runtime.<br>This kind of &quot;implicit&quot; is a basic form of type inference for dependently typed languages.<br>If you have a polymorphic identity function \(id=\lambda t: *.\lambda x: t. x\) then<br>you&#39;d like to be able to call it like \(id(7)\) instead of \(id(\mathbb{N})(7)\), but<br>you would consider this a notational shorthand, nothing more.<br>That&#39;s called an &quot;implicit&quot; argument but it isn&#39;t the type of &quot;implicit&quot; we consider here for implicit products.<br></span></div><div><span>So now we know why they&#39;re called *implicit* products.<br>Why are they called implicit *products?*<br></span></div><div><span>This might be a more basic point for those quite familiar with dependent types,<br>but it&#39;s an easy source of confusion so I figured I&#39;d touch on it anyway.<br>In general in type theory, a product is a type of tuple: <br>the product of \(\mathbb{N}\) and \(\mathbb{Z}\) is the type of pairs of natural numbers and integers,<br>and is written \(\mathbb{N}\times\mathbb{Z}\). <br>It&#39;s a Cartesian product, to use a term more broadly familiar.<br>This is really confusing because \(\Pi\)-types are often referred to as &quot;products,&quot;<br>or &quot;dependent product types,&quot; as well as being called &quot;dependent function types.&quot;<br>My understanding for why this is the case is that we can think of a tuple (an element of a product type) as a function from<br>\(\mathbb{N}\) to values of various types. <br>These are &quot;indexed&quot; by the natural number given.<br>So \((5, {4})\) is a tiny function mapping \(0\) to \(5\) and \(1\) to \({4}\).<br>The return type of this function depends on the integer given as its argument: it&#39;s a dependent function type!<br>A \(\Pi\)-type indexes values of various types (the family of return types) using the values of the argument type.<br>It is this function-type meaning of &quot;product&quot; that is used in the term &quot;implicit product.&quot;<br></span></div><h3><span>Conclusion<br></span></h3><div><span>That&#39;s all I have to say about implicit products for now.<br>I think they&#39;re a really cool idea and I&#39;m adding them to my own dependently-typed language<br>[https://github.com/RyanBrewer317/Saber](Saber).<br>If you want to play with a finished implemenation, though,<br>the most famous by far would be [https://cedille.github.io/](Cedille).<br></span></div></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>