<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title>Ryan Brewer&#39;s Blog - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="The place Ryan writes his thoughts and shows off SaberVM and other cool projects."><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><link rel="stylesheet" href="/style.css"></head><body><div><script>
var _ARCTIC_C;
if (typeof HTMLDocument === 'undefined') HTMLDocument = Document;
let arctic_dom_content_loaded_listeners = [];
HTMLDocument.prototype.arctic_addEventListener = HTMLDocument.prototype.addEventListener;
HTMLDocument.prototype.addEventListener = function(type, listener, options) {
  if (type === 'DOMContentLoaded') {
    arctic_dom_content_loaded_listeners.push(listener);
    document.arctic_addEventListener(type, listener, options);
  } else document.arctic_addEventListener(type, listener, options);
}
       </script><div id="arctic-app"><div><title>Search Posts - Ryan Brewer</title><meta name="description" content="Search Ryan&#39;s past posts"><script>const POSTS = {"cricket": {"id": "cricket", "url": "/posts/cricket", "title": "The Cricket Language", "date": "September 12, 2024", "tags": ["programming", "language", "tech", "announce", "announcement", "cricket", "untyped", "gradual", "gradually", "gradually-typed", "dynamically", "dynamically-typed", "dynamic", "type", "typed", "types", "object", "objects", "object-oriented", "oriented", "immutable"], "description": "Cricket is a lazy gradually-typed functional language with objects. It's very tiny but very expressive; anyone can implement it themselves!"},
"getting-started-category-theory": {"id": "getting-started-category-theory", "url": "/posts/getting-started-category-theory", "title": "Getting Started with Category Theory", "date": "July 29, 2024", "tags": ["intro", "introduction", "getting", "started", "category", "theory", "categories", "object", "objects", "morphism", "morphisms", "functor", "functors", "natural", "transformation", "transformations", "product", "coproduct", "products", "coproducts", "limit", "colimit", "limits", "colimits", "initial", "terminal", "diagram", "diagrams", "bifunctor", "bifunctors", "monoid", "monoidal", "preorder", "universal", "construction", "cone", "cocone", "cones", "cocones", "co-cone", "co-cones", "beginner", "friendly", "reference", "getting", "started"], "description": "Category theory is a beautiful and powerful field but it can feel impenetrable without the right entry point. This post hopes to serve as a sort of beginner's guide and reference."},
"type-of-sprintf": {"id": "type-of-sprintf", "url": "/posts/type-of-sprintf", "title": "The Type of Sprintf", "date": "May 14, 2024", "tags": ["dependent", "type", "types", "theory", "dependently", "large", "elimination", "eliminations", "sprintf", "agda", "printf", "format", "string", "refinement"], "description": "Most static type systems wouldn't let you make something like sprintf, whose type is determined by a format string. Dependent types can save the day!"},
"simple-programming-languages": {"id": "simple-programming-languages", "url": "/posts/simple-programming-languages", "title": "Simple Programming Languages", "date": "March 20, 2024", "tags": ["simple", "programming", "language", "languages", "simplicity", "readability", "gleam", "go", "c", "ready-at-hand", "ready", "at", "hand", "first-order", "first", "order", "reason", "reasoning", "iteration", "cycle", "single", "way", "static", "type", "system", "obj", "heidegger", "aesthetic", "aesthetics"], "description": "Simple programming languages are wonderful to work in. But what is it about them that actually makes them simple? And why do we like that so much?"},
"typechecking-svm": {"id": "typechecking-svm", "url": "/posts/typechecking-svm", "title": "Advanced Typechecking for Stack-Based Languages", "date": "February 18, 2024", "tags": ["sabervm", "advanced", "type", "types", "typechecking", "checking", "check", "typecheck", "stack", "based", "stack-based", "language", "languages"], "description": "This post discusses the interesting typechecker of SaberVM, which uses a stack-based bytecode language with a powerful type system."},
"beginners-guide-pl-academia": {"id": "beginners-guide-pl-academia", "url": "/posts/beginners-guide-pl-academia", "title": "A Beginner's Guide to Programming Language Academia", "date": "January 28, 2024", "tags": ["beginner", "guide", "pl", "programming", "language", "languages", "academia", "paper", "papers", "academic", "list", "experience"], "description": "This post briefly maps out many different subfields of programming language theory, in an effort to make it more accessible to those outside academia."},
"safe-mmm-with-coeffects": {"id": "safe-mmm-with-coeffects", "url": "/posts/safe-mmm-with-coeffects", "title": "Safe Manual Memory Management with Coeffects", "date": "January 25, 2024", "tags": ["safe", "safety", "manual", "memory", "management", "coeffect", "coeffects", "sabervm", "saber", "tech", "programming", "language", "languages", "static", "analysis"], "description": "Using ideas from Crary et al.'s Calculus of Capabilities, I discuss the coeffectful memory management used in SaberVM."},
"announcing-sabervm": {"id": "announcing-sabervm", "url": "/posts/announcing-sabervm", "title": "Announcing the Saber Virtual Machine", "date": "January 18, 2024", "tags": ["announce", "announcing", "announcement", "svm", "saber", "vm", "sabervm", "virtual", "abstract", "machine", "exception", "exceptions", "handling", "crash", "crashing", "microreboot", "reboot", "region", "regions", "capability", "capabilities", "morrisett", "language", "tech", "technology", "bytecode", "stack", "vale", "generational"], "description": "This post announces SaberVM, an abstract machine for functional programs that guarantees safety, reliability, and portability."},
"security-crashing-modal-logic": {"id": "security-crashing-modal-logic", "url": "/posts/security-crashing-modal-logic", "title": "Security and Crashing with Modal Logic", "date": "December 17, 2023", "tags": ["security", "crash", "crashing", "modal", "logic", "monad", "monadic", "comonad", "comonadic", "assert", "assertion", "noninterference", "secret", "public", "possibility", "necessity", "possibly", "necessarily", "tech", "technology", "software", "coding", "dependency", "execution"], "description": "Modal logic is a beautiful field of logic that can be applied to computer science in a few ways, one of which we explore in this post. It can elucidate security concepts and how and why to crash software."},
"implicit-products-better-forall": {"id": "implicit-products-better-forall", "url": "/posts/implicit-products-better-forall", "title": "Implicit Products: A Better Type-Theoretic \"Forall\"", "date": "December 10, 2023", "tags": ["implicit", "product", "products", "type", "types", "dependent", "dependently", "theory", "forall", "for all", "set", "logic", "universal", "quantifier", "quantifiers", "lambda", "intersection", "runtime", "erasure", "proof", "irrelevance", "cedille", "cdle"], "description": "Implicit products are a fascinating approach to universal quantification in dependent type theory, as well as proof irrelevance/erasure in compiler implementation."},
"logic-in-types": {"id": "logic-in-types", "url": "/posts/logic-in-types", "title": "An Introduction to Proofs with Dependent Types", "date": "December 3, 2023", "tags": ["dependent", "type", "types", "logic", "proof", "proofs", "assistants", "intro", "introduction"], "description": "This post introduces the basic ideas behind dependent-type-based proof assistants, and expressing logic with types and values."},
"first-post": {"id": "first-post", "url": "/posts/first-post", "title": "My First Blog Post", "date": "November 16, 2023", "tags": ["first post"], "description": "A test post for the blog."},
};</script><script>
function searchPostsKeyUp() {
  // Declare variables
  const $input = document.getElementById("search-posts");
  const q = $input.value.toLowerCase();
  const $menu = document.getElementById("search-posts-menu");
  $menu.replaceChildren(...Array.from($menu.children).sort((a, b) => {
    const aHits = getHits(q, POSTS[a.id]);
    const bHits = getHits(q, POSTS[b.id]);
    return bHits - aHits;
  }));
}
function getHits(q, p) {
  let hits = 0;
  for (const i in p.tags) if (q.includes(p.tags[i])) hits += 2;
  const words = p.description.split(" ");
  for (const i in words) if (q.includes(words[i])) hits += 1;
  return hits;
}
  </script><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe" onclick="window.location.href = &#39;/feed.rss&#39;"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><input type="text" id="search-posts" placeholder="Search..." onkeyup="searchPostsKeyUp()" title="Enter search terms"><ul id="search-posts-menu"><li id="cricket" class="post-thumbnail"><h3><a href="../posts/cricket">The Cricket Language</a></h3><div class="subtle-text">September 12, 2024</div><p>Cricket is a lazy gradually-typed functional language with objects. It&#39;s very tiny but very expressive; anyone can implement it themselves!</p></li><li id="getting-started-category-theory" class="post-thumbnail"><h3><a href="../posts/getting-started-category-theory">Getting Started with Category Theory</a></h3><div class="subtle-text">July 29, 2024</div><p>Category theory is a beautiful and powerful field but it can feel impenetrable without the right entry point. This post hopes to serve as a sort of beginner&#39;s guide and reference.</p></li><li id="type-of-sprintf" class="post-thumbnail"><h3><a href="../posts/type-of-sprintf">The Type of Sprintf</a></h3><div class="subtle-text">May 14, 2024</div><p>Most static type systems wouldn&#39;t let you make something like sprintf, whose type is determined by a format string. Dependent types can save the day!</p></li><li id="simple-programming-languages" class="post-thumbnail"><h3><a href="../posts/simple-programming-languages">Simple Programming Languages</a></h3><div class="subtle-text">March 20, 2024</div><p>Simple programming languages are wonderful to work in. But what is it about them that actually makes them simple? And why do we like that so much?</p></li><li id="typechecking-svm" class="post-thumbnail"><h3><a href="../posts/typechecking-svm">Advanced Typechecking for Stack-Based Languages</a></h3><div class="subtle-text">February 18, 2024</div><p>This post discusses the interesting typechecker of SaberVM, which uses a stack-based bytecode language with a powerful type system.</p></li><li id="beginners-guide-pl-academia" class="post-thumbnail"><h3><a href="../posts/beginners-guide-pl-academia">A Beginner&#39;s Guide to Programming Language Academia</a></h3><div class="subtle-text">January 28, 2024</div><p>This post briefly maps out many different subfields of programming language theory, in an effort to make it more accessible to those outside academia.</p></li><li id="safe-mmm-with-coeffects" class="post-thumbnail"><h3><a href="../posts/safe-mmm-with-coeffects">Safe Manual Memory Management with Coeffects</a></h3><div class="subtle-text">January 25, 2024</div><p>Using ideas from Crary et al.&#39;s Calculus of Capabilities, I discuss the coeffectful memory management used in SaberVM.</p></li><li id="announcing-sabervm" class="post-thumbnail"><h3><a href="../posts/announcing-sabervm">Announcing the Saber Virtual Machine</a></h3><div class="subtle-text">January 18, 2024</div><p>This post announces SaberVM, an abstract machine for functional programs that guarantees safety, reliability, and portability.</p></li><li id="security-crashing-modal-logic" class="post-thumbnail"><h3><a href="../posts/security-crashing-modal-logic">Security and Crashing with Modal Logic</a></h3><div class="subtle-text">December 17, 2023</div><p>Modal logic is a beautiful field of logic that can be applied to computer science in a few ways, one of which we explore in this post. It can elucidate security concepts and how and why to crash software.</p></li><li id="implicit-products-better-forall" class="post-thumbnail"><h3><a href="../posts/implicit-products-better-forall">Implicit Products: A Better Type-Theoretic &quot;Forall&quot;</a></h3><div class="subtle-text">December 10, 2023</div><p>Implicit products are a fascinating approach to universal quantification in dependent type theory, as well as proof irrelevance/erasure in compiler implementation.</p></li><li id="logic-in-types" class="post-thumbnail"><h3><a href="../posts/logic-in-types">An Introduction to Proofs with Dependent Types</a></h3><div class="subtle-text">December 3, 2023</div><p>This post introduces the basic ideas behind dependent-type-based proof assistants, and expressing logic with types and values.</p></li><li id="first-post" class="post-thumbnail"><h3><a href="../posts/first-post">My First Blog Post</a></h3><div class="subtle-text">November 16, 2023</div><p>A test post for the blog.</p></li></ul></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></div></div><script>
// SPA algorithm stolen from Hayleigh Thompson's wonderful Modem library
async function go_to(url, loader, back) {
  if (!back && url.pathname === window.location.pathname) {
    if (url.hash) document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else window.scrollTo(0, 0);
    return;
  }
  document.dispatchEvent(new Event('beforeunload'));
  document.dispatchEvent(new Event('unload'));
  for (let i = 0; i < arctic_dom_content_loaded_listeners.length; i++)
    document.removeEventListener('DOMContentLoaded', arctic_dom_content_loaded_listeners[i]);
  arctic_dom_content_loaded_listeners = [];
  const $app = document.getElementById('arctic-app');
  if (loader) $app.innerHTML = '<div id="arctic-loader"></div>';
  if (!back) window.history.pushState({}, '', url.href);
  // handle new path
  const response = await fetch('/__pages/' + url.pathname + '/index.html');
  if (!response.ok) response = await fetch('/__pages/404.html');
  if (!response.ok) return;
  const html = await response.text();
  $app.innerHTML = '<script>_ARCTIC_C=0;</'+'script>'+html;
  // re-create script elements, so their javascript runs
  const scripts = $app.querySelectorAll('script');
  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    const n = document.createElement('script');
    n.setAttribute('defer', 'true');
    if (script.innerHTML === '') n.onload = 
      (n.onload || '') + 
      ';if(++_ARCTIC_C>=' +
      scripts.length +
      ')document.dispatchEvent(new Event(\'DOMContentLoaded\'));';
    else {
      const t = document.createTextNode(
        script.innerHTML +
        ';console.log(\'script\',_ARCTIC_C);' +
        'if(++_ARCTIC_C>=' +
        scripts.length +
        ')document.dispatchEvent(new Event(\'DOMContentLoaded\'));'
      );
      n.appendChild(t);
    }
    for (let j = 0; j < script.attributes.length; j++) {
      const attr = script.attributes[j];
      n.setAttribute(attr.name, attr.value);
    }
    script.parentNode.replaceChild(n, script);
  }
  window.requestAnimationFrame(() => {
    if (url.hash)
      document.getElementById(url.hash.slice(1))?.scrollIntoView();
    else
      window.scrollTo(0, 0);
  });
  // setTimeout(() => document.dispatchEvent(new Event('DOMContentLoaded')), 100); // i cri ),x
}
document.addEventListener('click', async function(e) {
  const a = find_a(e.target);
  if (!a) return;
  try {
    const url = new URL(a.href);
    const is_external = url.host !== window.location.host;
    if (is_external) return;
    event.preventDefault();
    go_to(url, false, false);
  } catch {
    return;
  }
});
window.addEventListener('popstate', (e) => {
  e.preventDefault();
  const url = new URL(window.location.href);
  go_to(url, false, true);
});
function find_a(target) {
  if (!target || target.tagName === 'BODY') return null;
  if (target.tagName === 'A') return target;
  return find_a(target.parentElement);
}</script></div></body></html>