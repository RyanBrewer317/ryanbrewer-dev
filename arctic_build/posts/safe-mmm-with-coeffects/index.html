<!doctype html>
<html lang="en"><head><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-BDZJ8SX3Y1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
        </script><title> - Ryan Brewer</title><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Ryan Brewer&#39;s Blog" href="https://ryanbrewer.dev/feed.rss"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="true"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&amp;display=swap"><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" async="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script>
window.MathJax = {
  loader: {load: ['[tex]/unicode']},
  tex: {packages: {'[+]': ['unicode']}},
};
        </script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script><script>hljs.highlightAll();</script><script type="module">import '../../../style.css';</script></head><body><nav id="nav"><div id="nav-dropdown" onclick="document.getElementById(&#39;nav&#39;).classList.toggle(&#39;dropdown&#39;);document.body.classList.toggle(&#39;noscroll&#39;);">☰</div><a href="/" id="nav-home">Ryan Brewer</a><a href="/posts" id="nav-posts">Posts</a><a href="/wiki" id="nav-wiki">Wiki</a><a href="/contact" id="nav-contact">Contact</a><a href="/demos" id="nav-demos">Demos</a><a href="/feed.rss" id="nav-subscribe"><img src="/rss-icon.png" id="rss-subscribe-icon">Subscribe</a></nav><div id="body"><h1></h1><div class="date">January 1, 2024</div><div><span>Recently I [https://ryanbrewer.dev/posts/announcing-svm.html](announced) SaberVM,<br>which uses a fun combination of features to express quite a lot in a safe way.<br>One of the big interesting parts of SaberVM is its memory safety scheme.<br>Part of SaberVM&#39;s strategy is at compiletime, like how Rust guarantees memory safety at compiletime.<br>These sorts of approaches have seen a lot of interest lately.<br>SaberVM&#39;s compiletime strategy is quite a bit different from Rust&#39;s, however, and isn&#39;t a well-known strategy outside of academia,<br>so it might be an exciting new opening in the design space for language designers who haven&#39;t seen it before.<br>For marketing purposes I&#39;ll call it &quot;capability-based memory safety,&quot; but I didn&#39;t invent it.<br>I thought it could be helpful if I devoted a post to explain capability-based memory safety and why I chose it for SaberVM.<br></span></div><div><span>This post assumes a passing familiarity with use-after-free bugs,<br>[https://en.wikipedia.org/wiki/Continuation-passing_style](continuation-passing style),<br>and memory arenas.<br></span></div><h3><span>A Calculus of Capabilities<br></span></h3><div><span>The system I&#39;m using is almost entirely taken from the 1999 paper <br>[https://dl.acm.org/doi/10.1145/292540.292564](Typed Memory Management in a Calculus of Capabilities),<br>by Karl Crary, David Walker, and Greg Morrisett. <br>My adjustments are generally about making it work for a stack-based bytecode language, and I don&#39;t discuss them here.<br>I highly recommend reading the paper, as it&#39;s short and accessible for an academic paper.<br>However, for those unfamiliar with programming language papers and that sort of academic writing,<br>this post attempts to talk through the ideas in a more informal, casual style.<br></span></div><div><span>I want to emphasize that I didn&#39;t come up with this idea, and the paper is fairly well-cited.<br>Compile-time memory safety ideas are much more well-known within academia than outside of it,<br>where most people only know of what Rust is doing.<br>Some of these ideas made it into the Cyclone language, which actually had a significant <br>[https://doc.rust-lang.org/reference/influences.html](influence) on Rust&#39;s design.<br></span></div><div><span>First, we think of all our memory being divided up into *regions,* which are basically arenas. <br>To simplify, we won&#39;t consider nested regions, nor an unfreeable &quot;heap region&quot; for allocating without a region.<br>If you want to allocate something in the heap, you must have made a region first.<br></span></div><div><span>To access the memory in a region, we need *capabilities.*<br>A capability is basically a set of memory access privileges.<br>Say we&#39;re using a region called `r`.<br>If I want to store a point `(3, 4)` in `r`, I need a *read-write* capability for `r`, which I&#39;ll write as `+r`. <br>Then the type of the point will be `(int, int)@r` where `r` is the name of the region.<br>Then if I want to access the contents of this point, like `fst(p)`, I *also* need the `+r` capability.<br></span></div><div><span>In this system there&#39;s no way to free the point, since regions are like arenas. <br>SaberVM has an extension to the idea that allows freeing individual values, but I won&#39;t go into that here.<br>Whole regions can be freed together, though, which needs a *unique* capability `1r`.<br>Unique capabilities grant read-write permission but they additionally can&#39;t be duplicated in a set of capabilities; hence the name.<br>That means if you have a capability `{+r1, 1r2}`, then you know for sure that `r1` and `r2` are different regions.<br>If region polymorphism is involved, you know the region variables won&#39;t be instantiated with the same region,<br>since `r2` would then exist in the capability set twice.<br>This is really important, because otherwise you could free `r2` and then read and write in `r1`, which might be the memory you just freed!<br></span></div><div><span>Note that this means capability sets aren&#39;t *really* sets.<br>`{+r}` is equivalent to `{+r, +r}`, but `{1r}` and `{1r, 1r}`<br>aren&#39;t equivalent because `{1r, 1r}` is an unsatisfiable capability<br>asserting that `r`\(\neq\)`r`.<br></span></div><h3><span>Region Borrowing<br></span></h3><div><span>If creating a region gives you the unique right to free it,<br>and that right is needed and consumed when you free it,<br>then how do read-write (nonunique) capabilities come about?<br>You could instantiate a `+r` with a `1r`, and duplicate the `+r` as much as you want, but then<br>you couldn&#39;t get back the access you need to free the region later, so what do you do?<br>The amazing answer is *bounded capability polymorphism.*<br></span></div><div><span>Functions can be capability-polymorphic, meaning they can have capability variables that are instantiated at each callsite.<br>These variables can have a *bound,* which is some set of privileges that they at least grant.<br>For example, `{1r}`\(\le\)`{+r}` is always true and means that the set `{1r}` satisfies anything that the set `{+r}` satisfies <br>(but not necessarily vice versa).<br>Therefore, a bounded capability variable looks like `c≤C` for some set of capabilities `C`, <br>and can only be instantiated with a set of capabilities that satisfies `C`.<br>So if we have `c≤{+r1}`, we know that it could be instantiated with, say, `{+r1}`, `{1r1}`, or `{+r1, +r2}`,<br>but not `{+r2}` or `{}`.<br>Why is this so helpful? Well for one we know that `c` grants at least as much privilege as `{+r1}`, so we can safely read and write to `r1`.<br>But the much more interesting consequence for a [https://en.wikipedia.org/wiki/Continuation-passing_style](CPS)-based language <br>like SaberVM and the language in the paper is *region borrowing.*<br></span></div><div><span>Say I have a CPS function of type `forall r: Rgn, c≤{+r}. [c](int, int, [c](int)-&gt;void)-&gt;void`.<br>What does this mean? It has a polymorphic region variable `r` and a bounded polymorphic capability variable `c`<br>which has at least the privilege to read and write in `r`.<br>The `[c]` notation means that the function can only be called in a context where capability set `c` (our bounded variable) is satisfied. <br>That is, we know this function will at least be allowed to read and write in the instantiated `r` regions.<br>It takes as arguments two integers and a continuation that also needs `c` to be satisfied, and which takes an integer.<br>You can think of this as a CPS&#39;d addition or multiplication function or something like that,<br>that uses heap allocation for some reason.<br></span></div><div><span>We can call that function instantiating `r` with a region `r2` and instantiating `c` with `{1r2}`, since `{1r2}`\(\le\)`{+r2}`. <br>That means our function type becomes `[{1r2}](int, int, [{1r2}](int)-&gt;void)-&gt;void`, <br>and can be given a continuation that is able to free `r2`.<br>This is in spite of the fact that the code inside the function is using a duplicable `c≤{+r2}` capability and is accessing `r2` willy-nilly.<br>This is perfectly safe, because either the continuation gets dropped and the program continues with only the `+r2` capability<br>(never again being able to free `r2`) or the continuation is eventually called (via the `c≤{+r}` capability) and the `1r2` capability is regained,<br>with the `+r2` capability forever lost (until the next borrow :).<br>These ideas can be used in a non-CPS setting too (see [https://cyclone.thelanguage.org/wiki/Type-Checking%20Regions/](Cyclone)), <br>but CPS simplifies this process a lot.<br></span></div><div><span>As you can see, this allows a kind of region borrowing, where `1r` capabilities are temporarily made `+r` in a safe way.<br></span></div><div><span>Capabilities are purely compiletime things, like types,<br>and each point in the program has a capability for everything that&#39;s allowed at that point.<br>Note that a uniqueness capability doesn&#39;t put any uniqueness restriction on the values the <br>program computes with; pointers can always be duplicated as much as you want, and the type system still<br>prevents use-after-free bugs.<br>When a region `r` is freed, it&#39;s impossible to obtain a capability for it, so pointers into the region<br>can&#39;t be dereferenced, even though they can still be passed around.<br></span></div><h3><span>Coeffects<br></span></h3><div><span>This part of the post assumes some familiarity with monads and effect systems. <br>A passing familiarity of comonads or category theory will help. <br>Feel free to skip to the conclusion of the post if this isn&#39;t understandable!<br></span></div><div><span>I wanted to close out the body of this post with a fun theoretical discussion.<br>Recall that function types are written like `[C](a)-&gt;b`, <br>where `C` is a set of capabilities that must be satisfied for the function to be safely called.<br>This approach to guaranteeing safety at compiletime is called *coeffectful.*<br>You may have heard of *effects,* and how they are modeled with *monads.*<br>Coeffects are the dual of effects: they don&#39;t change the environment as they execute,<br>they *require* some fact about the environment *to be able* to start executing.<br></span></div><div><span>Comonads are the duals of monads.<br>Instead of `return: a -&gt; m a` they have `extract: c a -&gt; a`.<br>Instead of `join: m (m a) -&gt; m a` they have `duplicate: c a -&gt; c (c a)`.<br>Instead of `bind: m a -&gt; (a -&gt; m b) -&gt; m b` they have `cobind: c a -&gt; (c a -&gt; b) -&gt; c b`.<br>We won&#39;t generally assume comonads have an `fmap: (a -&gt; b) -&gt; (c a -&gt; c b)`<br>since that requirement can get in the way and isn&#39;t needed in true category theory.<br>(It&#39;s referred to as *tensorial strength* if you need a search term).<br></span></div><div><span>Effects don&#39;t make monads. They only make sense for functions, not values.<br>So there&#39;s no `IO(a)` in an effect system, to use `IO` effects as a running example.<br>There&#39;s no `return: a-&gt;IO(a)` unless `return` actually performs an IO effect.<br>There&#39;s no way for `join: IO(IO(a)) -&gt; IO(a)` to make sense for an effect system; almost because it&#39;s too trivial.<br>This is why effect systems often write `a -[IO]-&gt; b` instead of `a -&gt; IO(b)` for effectful functions.<br></span></div><div><span>Coeffects are the same with comonads. They only make sense for functions, not values.<br>So I won&#39;t be able to define `extract` or `duplicate` for this capability system.<br>However, it&#39;s imaginable that you can *simulate* this capability system with comonads.<br>A very fascinating discussion of this happens in [https://arxiv.org/abs/1907.07283](this paper)<br>by Vikraman Choudhury and Neel Krishnaswami, two fantastic researchers to keep an eye on.<br>They use comonads in a nonpure language to simulate purity, instead of the typical reverse of<br>using monads in a pure language to simulate nonpurity.<br>They also make a very explicit connection between comonads and capability-based security,<br>and offer some fascinating category theory relating capability systems and linear logic.<br>Choudhury in particular is a top researcher on comonadic security right now,<br>and I&#39;ll recommend another interesting [https://dl.acm.org/doi/abs/10.1145/3563335](paper) of his<br>on using comonads, this time for information security. I talked more about that paper in this <br>[https://ryanbrewer.dev/posts/security-crashing-modal-logic.html](post).<br></span></div><div><span>The Crary, et al. paper on capabilities doesn&#39;t make any mention of comonads, coeffects, or category theory.<br>However, the Choudhury and Krishnaswami paper fills me with confidence about my intuition that <br>this is indeed a coeffect system at heart. The Crary, et al. paper *does* mention *effect* systems, though, saying,<br></span></div><div>*<span>&quot;The relationship between effects and capabilities is quite close. <br>A necessary prerequisite for the use of either system is type inference, <br>performed by a programmer or compiler, and much of the research into effects systems has concentrated on this difficult task. <br>Because of the focus on inference, effect systems are usually formulated as a bottom-up synthesis of effects. <br>Our work may viewed as producing verifiable evidence of the correctness of an inference. <br>Hence, while effect systems typically work bottom-up, specifying the effects that might occur, <br>we take a top-down approach, specifying by capabilities the effects that are* permitted to occur.&quot;<br></span></div><div><span>This again sounds like the dual of an effect system, and like much of the literature on coeffects.<br>Functions are annotated with labels specifying what is allowed to occur in the function,<br>and thus the function can only be called when those things are allowed for the caller.<br></span></div><div><span>I think coeffects are a really interesting way to handle memory safety.<br>SaberVM doesn&#39;t require that any values are used linearly, so there are no<br>&quot;move semantics&quot; or anything like that.<br>To do something with memory in a function, you just give that function the capability<br>to do that thing, and the type system guarantees that the function will only be <br>called when the memory operations are safe to perform. <br>The memory in freed regions will never be read or written, using a very permissive compiletime analysis<br>that is completely compositional (so functions can be analyzed individually).<br></span></div><h3><span>SaberVM<br></span></h3><div><span>As a final detail, it&#39;s worth mentioning why I chose this for SaberVM instead of other approaches.<br>I talk about this at length in my [https://ryanbrewer.dev/posts/announcing-svm.html](announcement)<br>and even more on the README of the SaberVM [https://github.com/RyanBrewer317/SaberVM](github),<br>so I won&#39;t go into much detail here.<br></span></div><div><span>SaberVM should be able to support garbage collection, since it&#39;s intended to be a target for functional languages. <br>Ideally it can do this without FFI, since SaberVM binaries that use FFI can no longer be blindly trusted. <br>That means there can be very few limitations on how memory is accessed.<br>I&#39;m pairing this system with Vale&#39;s [https://verdagon.dev/blog/generational-references](generational references)<br>so that values within a region can be freed and reused, without freeing the whole region.<br>This gives a lot of expressivity, and I&#39;m a big fan of what Vale is doing.<br>The region system offers a way to deal with the fragmentation issues generational references can cause,<br>because there are certain points in a program where we can guarantee at compiletime<br>that some memory won&#39;t be accessed ever again (namely, when we free the region),<br>which means we can combine all that memory into a single chunk to start allocating out of<br>without fear of how old pointers could dereference into it.<br></span></div><div><span>That really is the primary reason for using regions, but they offer a number of other benefits as well.<br>You can use many small regions if you don&#39;t want to be reusing the memory in them for some reason,<br>and they work like arenas at runtime so have very fast allocation and deallocation.<br>I&#39;d love to see more languages start incorporating capability-based (or coeffectful) memory safety guarantees.<br></span></div><h3><span>Conclusion<br></span></h3><div><span>This post is perhaps longer and more technical than some of my others.<br>Public interest in SaberVM since I [https://ryanbrewer.dev/posts/announcing-svm.html](announced) <br>it has far exceeded my expectations, <br>so I thought it might be appreciated if I wrote a few posts explaining the magic sauce that makes it work.<br></span></div><div><span>Aside from that, I&#39;ve thought for a long time that coeffects are very underappreciated<br>for programming language safety guarantees. <br>That was a big part of why I wrote this [https://ryanbrewer.dev/posts/security-crashing-modal-logic.html](post)<br>which talked a little more about how comonads (and the necessity operator from modal logic, which is a comonad)<br>can be used for information security.<br></span></div><div><span>I hope this post is interesting for people.<br>If you found it interesting, I recommend reading the original [https://dl.acm.org/doi/10.1145/292540.292564](paper),<br>and checking out the [https://cyclone.thelanguage.org/](Cyclone) language.<br>I also of course recommend checking out [https://github.com/RyanBrewer317/SaberVM](SaberVM) if you haven&#39;t.<br>If you want to see SaberVM&#39;s progress and are maybe even considering using it as the<br>backend of your functional language, consider<br>starring it on [https://github.com/RyanBrewer317/SaberVM](github), or even<br>sponsoring my work on [https://github.com/sponsors/RyanBrewer317](github) or <br>[https://ko-fi.com/ryanbrewer](ko-fi)!<br></span></div></div><div><div style="height:100pt;"></div><p id="copyright-notice" class="subtle-text">© 2024 Ryan Brewer.</p><script src="/__/firebase/8.10.1/firebase-app.js"></script><script src="/__/firebase/8.10.1/firebase-analytics.js"></script><script src="/__/firebase/init.js"></script><script>firebase.analytics();</script></div></body></html>